{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"SMIRNOFF Energy Evaluations <p>Differentiably evaluate energies of molecules using SMIRNOFF force fields</p> <p> </p> <p>The <code>smee</code> framework aims to offer a simple API for differentiably evaluating the energy of SMIRNOFF  force fields applied to molecules using <code>pytorch</code>.</p> <p>The package currently supports evaluating the energy of force fields that contain: </p> <ul> <li><code>Bonds</code>, <code>Angles</code>, <code>ProperTorsions</code> and <code>ImproperTorsions</code> </li> <li><code>vdW</code>, <code>Electrostatics</code>, <code>ToolkitAM1BCC</code>, <code>LibraryCharges</code></li> <li><code>VirtualSites</code></li> </ul> <p>parameter handlers in addition to limited support for registering custom handlers.</p> <p>It further supports a number of functional forms included in <code>smirnoff-plugins</code>, namely:</p> <ul> <li><code>DoubleExponential</code></li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>This package can be installed using <code>conda</code> (or <code>mamba</code>, a faster version of <code>conda</code>):</p> <pre><code>mamba install -c conda-forge smee\n</code></pre> <p>The example notebooks further require you install <code>jupyter</code>, <code>nglview</code>, and <code>smirnoff-plugins</code>:</p> <pre><code>mamba install -c conda-forge jupyter nglview \"smirnoff-plugins &gt;=0.0.4\"\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started, see the examples.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>Copyright (c) 2023, Simon Boothroyd</p>"},{"location":"development/","title":"Development","text":"<p>To create a development environment, you must have <code>mamba</code> installed.</p> <p>A development conda environment can be created and activated with:</p> <pre><code>make env\nconda activate smee\n</code></pre> <p>To format the codebase:</p> <pre><code>make format\n</code></pre> <p>To run the unit tests:</p> <pre><code>make test\n</code></pre> <p>To serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>This directory contains a number of examples of how to use <code>smee</code>. They currently include:</p> <ul> <li>Evaluating the energy of a water dimer with virtual sites</li> <li>Minimizing the conformer of a molecule</li> <li>Computing the gradient of the energy w.r.t. force field parameters</li> <li>Registering custom parameter handlers</li> <li>Differentiably compute ensemble averages from MD simulations</li> </ul>"},{"location":"examples/compute-energy/","title":"Computing energies using smee","text":"In\u00a0[1]: Copied! <pre>import openff.toolkit\nimport openff.units\nimport torch\n\nwater = openff.toolkit.Molecule.from_smiles(\"O\")\nwater.generate_conformers(n_conformers=1)\n\nimport openff.interchange\n\ntip4p_interchange = openff.interchange.Interchange.from_smirnoff(\n    openff.toolkit.ForceField(\"tip4p_fb.offxml\"), water.to_topology()\n)\n</pre> import openff.toolkit import openff.units import torch  water = openff.toolkit.Molecule.from_smiles(\"O\") water.generate_conformers(n_conformers=1)  import openff.interchange  tip4p_interchange = openff.interchange.Interchange.from_smirnoff(     openff.toolkit.ForceField(\"tip4p_fb.offxml\"), water.to_topology() ) <pre></pre> <p>The interchange must then be mapped into collections of tensors:</p> In\u00a0[2]: Copied! <pre>import smee.converters\n\ntip4p_tensor_ff, [tip4p_topology] = smee.converters.convert_interchange(\n    tip4p_interchange\n)\n</pre> import smee.converters  tip4p_tensor_ff, [tip4p_topology] = smee.converters.convert_interchange(     tip4p_interchange ) <p>Note: The <code>convert_interchange</code> function can take either a single interchange object, or a list of multiple.</p> <p>These tensors are returned as:</p> <ul> <li>a <code>smee.ff.TensorForceField</code> oject: this stores the original values of the force field parameters in tensor form.</li> <li>a list of <code>smee.ff.TensorTopology</code> objects: each 'topology' will store basic information about each input molecule, in addition to matrices defining which parameters were assigned to which elements (e.g. bonds, angles, torsions) and any virtual sites that were added.</li> </ul> <p>To define fuller systems (e.g. dimers, condensed phase systems etc), we need to wrap the topologies in a system object:</p> In\u00a0[3]: Copied! <pre>tip4p_dimer = smee.TensorSystem([tip4p_topology], n_copies=[2], is_periodic=False)\n</pre> tip4p_dimer = smee.TensorSystem([tip4p_topology], n_copies=[2], is_periodic=False) <p>This mirrors how GROMACS topology files are defined, whereby individual species are parameterised and then a count of how many of each should be present is specified. This avoids the need to store multiple copies of the same parameters for each copy of a given molecule.</p> <p>We can then define the coordinates of our dimers:</p> In\u00a0[4]: Copied! <pre>water_conformer = torch.tensor(water.conformers[0].m_as(openff.units.unit.angstrom))\ntip4p_conformer = smee.add_v_site_coords(\n    tip4p_topology.v_sites, water_conformer, tip4p_tensor_ff\n)\n\ntip4p_conformers = torch.stack(\n    [\n        torch.vstack([tip4p_conformer, tip4p_conformer + torch.tensor(1.5 + i * 0.05)])\n        for i in range(40)\n    ]\n)\ntip4p_conformers.shape\n</pre> water_conformer = torch.tensor(water.conformers[0].m_as(openff.units.unit.angstrom)) tip4p_conformer = smee.add_v_site_coords(     tip4p_topology.v_sites, water_conformer, tip4p_tensor_ff )  tip4p_conformers = torch.stack(     [         torch.vstack([tip4p_conformer, tip4p_conformer + torch.tensor(1.5 + i * 0.05)])         for i in range(40)     ] ) tip4p_conformers.shape Out[4]: <pre>torch.Size([40, 8, 3])</pre> <p>For simplicity, we have created 40 dimer conformers, with a separation ranging from 1.5-3.5 \u00c5 by crudely shifting our initial conformer along the x-axis.</p> <p>Note: Conformers should either be tensor with a shape of <code>(n_particles, 3)</code> or <code>(n_conformers, n_particles, 3)</code>, and units of \u00c5._</p> <p>From the shape we can clearly see there are 40 conformers, each with coordinates for 8 particles (i.e. 3 for each water molecule + 1 virtual site on each).</p> <p>The energy each dimer can then be directly evaluated and plotted</p> In\u00a0[5]: Copied! <pre>tip4p_energies = smee.compute_energy(tip4p_dimer, tip4p_tensor_ff, tip4p_conformers)\n\nfrom matplotlib import pyplot\n\npyplot.plot(tip4p_energies, label=\"tip4p\")\npyplot.ylabel(\"Energy [kcal / mol]\");\n</pre> tip4p_energies = smee.compute_energy(tip4p_dimer, tip4p_tensor_ff, tip4p_conformers)  from matplotlib import pyplot  pyplot.plot(tip4p_energies, label=\"tip4p\") pyplot.ylabel(\"Energy [kcal / mol]\"); <p>The above can easily be repeated using the TIP3P water model, allowing us to compare the dimer energy curves.</p> In\u00a0[6]: Copied! <pre>tip3p_interchange = openff.interchange.Interchange.from_smirnoff(\n    openff.toolkit.ForceField(\"tip3p.offxml\"), water.to_topology()\n)\n\ntip3p_tensor_ff, [tip3p_tensor_topology] = smee.converters.convert_interchange(\n    tip3p_interchange\n)\ntip3p_dimer = smee.TensorSystem(\n    [tip3p_tensor_topology], n_copies=[2], is_periodic=False\n)\n\ntip3p_conformers = torch.stack(\n    [\n        torch.vstack([water_conformer, water_conformer + torch.tensor(1.5 + i * 0.05)])\n        for i in range(40)\n    ]\n)\n\ntip3p_energies = smee.compute_energy(tip3p_dimer, tip3p_tensor_ff, tip3p_conformers)\n\npyplot.plot(tip3p_energies, label=\"tip3p\")\npyplot.plot(tip4p_energies, label=\"tip4p\")\n\npyplot.ylabel(\"Energy [kcal / mol]\")\npyplot.legend();\n</pre> tip3p_interchange = openff.interchange.Interchange.from_smirnoff(     openff.toolkit.ForceField(\"tip3p.offxml\"), water.to_topology() )  tip3p_tensor_ff, [tip3p_tensor_topology] = smee.converters.convert_interchange(     tip3p_interchange ) tip3p_dimer = smee.TensorSystem(     [tip3p_tensor_topology], n_copies=[2], is_periodic=False )  tip3p_conformers = torch.stack(     [         torch.vstack([water_conformer, water_conformer + torch.tensor(1.5 + i * 0.05)])         for i in range(40)     ] )  tip3p_energies = smee.compute_energy(tip3p_dimer, tip3p_tensor_ff, tip3p_conformers)  pyplot.plot(tip3p_energies, label=\"tip3p\") pyplot.plot(tip4p_energies, label=\"tip4p\")  pyplot.ylabel(\"Energy [kcal / mol]\") pyplot.legend(); <p>A further advantage of storing our applied force field parameters in smee form is the ability to compute only the energy due to a particular handler (e.g. only LJ energies).</p> In\u00a0[7]: Copied! <pre>tip3p_lj_energies = smee.compute_energy_potential(\n    tip3p_dimer, tip3p_tensor_ff.potentials_by_type[\"vdW\"], tip3p_conformers\n)\ntip4p_lj_energies = smee.compute_energy_potential(\n    tip4p_dimer, tip4p_tensor_ff.potentials_by_type[\"vdW\"], tip4p_conformers\n)\n\npyplot.plot(tip3p_lj_energies, label=\"tip3p\")\npyplot.plot(tip4p_lj_energies, label=\"tip4p\")\n\npyplot.ylabel(\"LJ Energy [kcal / mol]\");\n</pre> tip3p_lj_energies = smee.compute_energy_potential(     tip3p_dimer, tip3p_tensor_ff.potentials_by_type[\"vdW\"], tip3p_conformers ) tip4p_lj_energies = smee.compute_energy_potential(     tip4p_dimer, tip4p_tensor_ff.potentials_by_type[\"vdW\"], tip4p_conformers )  pyplot.plot(tip3p_lj_energies, label=\"tip3p\") pyplot.plot(tip4p_lj_energies, label=\"tip4p\")  pyplot.ylabel(\"LJ Energy [kcal / mol]\");"},{"location":"examples/compute-energy/#computing-energies-using-smee","title":"Computing energies using <code>smee</code>\u00b6","text":"<p>This example will show how the energy of a water dimer (TIP4P-FB and TIP3P) in multiple conformations can be evaluated using <code>smee</code> framework.</p> <p>We start by creating the objects that will store our parameterized water dimer. First we will create a single water molecule, and parameterize it using OpenFF Interchange:</p>"},{"location":"examples/conformer-minimization/","title":"Conformer Minimization","text":"In\u00a0[1]: Copied! <pre>import openff.toolkit\nimport openff.units\nimport torch\n\nmolecule = openff.toolkit.Molecule.from_smiles(\"CC(=O)NC1=CC=C(C=C1)O\")\nmolecule.generate_conformers(n_conformers=1)\n\nconformer = torch.tensor(molecule.conformers[0].m_as(openff.units.unit.angstrom)) * 1.10\nconformer.requires_grad = True\n</pre> import openff.toolkit import openff.units import torch  molecule = openff.toolkit.Molecule.from_smiles(\"CC(=O)NC1=CC=C(C=C1)O\") molecule.generate_conformers(n_conformers=1)  conformer = torch.tensor(molecule.conformers[0].m_as(openff.units.unit.angstrom)) * 1.10 conformer.requires_grad = True <p>We specify that the gradient of the conformer is required so that we can optimize it using PyTorch.</p> <p>Parameterize the molecule using OpenFF Interchange and convert it into a PyTorch tensor representation.</p> In\u00a0[2]: Copied! <pre>import openff.interchange\n\ninterchange = openff.interchange.Interchange.from_smirnoff(\n    openff.toolkit.ForceField(\"openff-2.1.0.offxml\"),\n    molecule.to_topology(),\n)\n\nimport smee.converters\n\nforce_field, [topology] = smee.converters.convert_interchange(interchange)\n</pre> import openff.interchange  interchange = openff.interchange.Interchange.from_smirnoff(     openff.toolkit.ForceField(\"openff-2.1.0.offxml\"),     molecule.to_topology(), )  import smee.converters  force_field, [topology] = smee.converters.convert_interchange(interchange) <pre></pre> <p>We can minimize the conformer using any of PyTorch's optimizers.</p> In\u00a0[3]: Copied! <pre>import smee\n\noptimizer = torch.optim.Adam([conformer], lr=0.02)\n\nfor epoch in range(75):\n    energy = smee.compute_energy(topology, force_field, conformer)\n    energy.backward()\n\n    optimizer.step()\n    optimizer.zero_grad()\n\n    if epoch % 5 == 0 or epoch == 74:\n        print(f\"Epoch {epoch}: E={energy.item()} kcal / mol\")\n</pre> import smee  optimizer = torch.optim.Adam([conformer], lr=0.02)  for epoch in range(75):     energy = smee.compute_energy(topology, force_field, conformer)     energy.backward()      optimizer.step()     optimizer.zero_grad()      if epoch % 5 == 0 or epoch == 74:         print(f\"Epoch {epoch}: E={energy.item()} kcal / mol\") <pre>Epoch 0: E=102.10968017578125 kcal / mol\nEpoch 5: E=7.088213920593262 kcal / mol\nEpoch 10: E=-18.331130981445312 kcal / mol\nEpoch 15: E=-22.182296752929688 kcal / mol\nEpoch 20: E=-30.369152069091797 kcal / mol\nEpoch 25: E=-36.81045150756836 kcal / mol\nEpoch 30: E=-38.517852783203125 kcal / mol\nEpoch 35: E=-40.50505828857422 kcal / mol\nEpoch 40: E=-42.08476257324219 kcal / mol\nEpoch 45: E=-42.19199752807617 kcal / mol\nEpoch 50: E=-42.37827682495117 kcal / mol\nEpoch 55: E=-42.6767692565918 kcal / mol\nEpoch 60: E=-42.799903869628906 kcal / mol\nEpoch 65: E=-42.94251251220703 kcal / mol\nEpoch 70: E=-43.037200927734375 kcal / mol\nEpoch 74: E=-43.084136962890625 kcal / mol\n</pre> <p>We can then re-store the optimized conformer back into the molecule. Here we add the conformer to the molecule's conformer list, but we could also replace the original conformer.</p> In\u00a0[4]: Copied! <pre>molecule.add_conformer(conformer.detach().numpy() * openff.units.unit.angstrom)\nmolecule.visualize(backend=\"nglview\")\n</pre> molecule.add_conformer(conformer.detach().numpy() * openff.units.unit.angstrom) molecule.visualize(backend=\"nglview\") <pre>NGLWidget(max_frame=1)</pre>"},{"location":"examples/conformer-minimization/#conformer-minimization","title":"Conformer Minimization\u00b6","text":"<p>This example will show how to optimize a conformer of paracetamol.</p> <p>Load in a paracetamol molecule, generate a conformer for it, and perturb the conformer to ensure it needs minimization.</p>"},{"location":"examples/md-simulations/","title":"Ensemble Averages from MD Simulations","text":"In\u00a0[\u00a0]: Copied! <pre>import openff.interchange\nimport openff.toolkit\n\nimport smee.converters\n\ninterchanges = [\n    openff.interchange.Interchange.from_smirnoff(\n        openff.toolkit.ForceField(\"openff-2.0.0.offxml\"),\n        openff.toolkit.Molecule.from_smiles(smiles).to_topology(),\n    )\n    for smiles in (\"CCO\", \"CO\")\n]\n\ntensor_ff, topologies = smee.converters.convert_interchange(interchanges)\n\n# move the force field to the GPU for faster processing of the simulation\n# trajectories - the system and force field must be on the same device.\ntensor_ff = tensor_ff.to(\"cuda\")\n</pre> import openff.interchange import openff.toolkit  import smee.converters  interchanges = [     openff.interchange.Interchange.from_smirnoff(         openff.toolkit.ForceField(\"openff-2.0.0.offxml\"),         openff.toolkit.Molecule.from_smiles(smiles).to_topology(),     )     for smiles in (\"CCO\", \"CO\") ]  tensor_ff, topologies = smee.converters.convert_interchange(interchanges)  # move the force field to the GPU for faster processing of the simulation # trajectories - the system and force field must be on the same device. tensor_ff = tensor_ff.to(\"cuda\") <p>We will also flag that the vdW parameter gradients are required:</p> In\u00a0[\u00a0]: Copied! <pre>vdw_potential = tensor_ff.potentials_by_type[\"vdW\"]\nvdw_potential.parameters.requires_grad = True\n</pre> vdw_potential = tensor_ff.potentials_by_type[\"vdW\"] vdw_potential.parameters.requires_grad = True <p>We then define the full simulation boxes that we wish to simulate:</p> In\u00a0[\u00a0]: Copied! <pre>import smee\n\n# define a periodic box containing 216 ethanol molecules\nsystem_ethanol = smee.TensorSystem([topologies[0]], [216], is_periodic=True)\nsystem_ethanol = system_ethanol.to(\"cuda\")\n# define a periodic box containing 216 methanol molecules\nsystem_methanol = smee.TensorSystem([topologies[1]], [216], True)\nsystem_methanol = system_methanol.to(\"cuda\")\n# define a periodic box containing 128 ethanol molecules and 128 methanol molecules\nsystem_mixture = smee.TensorSystem(topologies, [128, 128], True)\nsystem_mixture = system_mixture.to(\"cuda\")\n</pre> import smee  # define a periodic box containing 216 ethanol molecules system_ethanol = smee.TensorSystem([topologies[0]], [216], is_periodic=True) system_ethanol = system_ethanol.to(\"cuda\") # define a periodic box containing 216 methanol molecules system_methanol = smee.TensorSystem([topologies[1]], [216], True) system_methanol = system_methanol.to(\"cuda\") # define a periodic box containing 128 ethanol molecules and 128 methanol molecules system_mixture = smee.TensorSystem(topologies, [128, 128], True) system_mixture = system_mixture.to(\"cuda\") <p>A tensor system is simply a wrapper around a set of topology objects that define parameters applied to individual molecules, and the number of copies of that topology that should be present similar to GROMACS topologies. The <code>is_periodic</code> flag indicates whether the system should be simulated in a periodic box.</p> <p>Here we have also moved the systems onto the GPU. This will allow us to much more rapidly compute ensemble averages from the trajectories, but is not required.</p> <p>We then also must define the simulation protocol that will be used to run the simulations. This consists of a config object that defines how to generate the system coordinates using PACKMOL, the set of energy minimisations /simulations to run as equilibration, and finally the configuration of the production simulation:</p> In\u00a0[\u00a0]: Copied! <pre>import tempfile\n\nimport openmm.unit\n\nimport smee.mm\n\ntemperature = 298.15 * openmm.unit.kelvin\npressure = 1.0 * openmm.unit.atmosphere\n\nbeta = 1.0 / (openmm.unit.MOLAR_GAS_CONSTANT_R * temperature)\n\n# we can run an arbitrary number of equilibration simulations / minimizations.\n# all generated data will be discarded, but the final coordinates will be used\n# to initialize the production simulation\nequilibrate_config = [\n    smee.mm.MinimizationConfig(),\n    # short NVT equilibration simulation\n    smee.mm.SimulationConfig(\n        temperature=temperature,\n        pressure=None,\n        n_steps=50000,\n        timestep=1.0 * openmm.unit.femtosecond,\n    ),\n    # short NPT equilibration simulation\n    smee.mm.SimulationConfig(\n        temperature=temperature,\n        pressure=pressure,\n        n_steps=50000,\n        timestep=1.0 * openmm.unit.femtosecond,\n    ),\n]\n# long NPT production simulation\nproduction_config = smee.mm.SimulationConfig(\n    temperature=temperature,\n    pressure=pressure,\n    n_steps=500000,\n    timestep=2.0 * openmm.unit.femtosecond,\n)\n</pre> import tempfile  import openmm.unit  import smee.mm  temperature = 298.15 * openmm.unit.kelvin pressure = 1.0 * openmm.unit.atmosphere  beta = 1.0 / (openmm.unit.MOLAR_GAS_CONSTANT_R * temperature)  # we can run an arbitrary number of equilibration simulations / minimizations. # all generated data will be discarded, but the final coordinates will be used # to initialize the production simulation equilibrate_config = [     smee.mm.MinimizationConfig(),     # short NVT equilibration simulation     smee.mm.SimulationConfig(         temperature=temperature,         pressure=None,         n_steps=50000,         timestep=1.0 * openmm.unit.femtosecond,     ),     # short NPT equilibration simulation     smee.mm.SimulationConfig(         temperature=temperature,         pressure=pressure,         n_steps=50000,         timestep=1.0 * openmm.unit.femtosecond,     ), ] # long NPT production simulation production_config = smee.mm.SimulationConfig(     temperature=temperature,     pressure=pressure,     n_steps=500000,     timestep=2.0 * openmm.unit.femtosecond, ) <p>We will further define a convenience function that will first simulate the system of interest (storing the trajectory in a temporary directory), and then compute ensemble averages over that trajectory:</p> In\u00a0[\u00a0]: Copied! <pre>import pathlib\n\nimport torch\n\n\ndef compute_ensemble_averages(\n    system: smee.TensorSystem, force_field: smee.TensorForceField\n) -&gt; dict[str, torch.Tensor]:\n    # computing the ensemble averages is a two step process - we first need to run\n    # an MD simulation using the force field making sure to store the coordinates,\n    # box vectors and kinetic energies\n    coords, box_vectors = smee.mm.generate_system_coords(system, force_field)\n\n    interval = 1000\n\n    # save the simulation output every 1000th frame (2 ps) to a temporary file.\n    # we could also save the trajectory more permanently, but as we do nothing\n    # with it after computing the averages in this example, we simply want to\n    # discard it.\n    with (\n        tempfile.NamedTemporaryFile() as tmp_file,\n        smee.mm.tensor_reporter(tmp_file.name, interval, beta, pressure) as reporter,\n    ):\n        smee.mm.simulate(\n            system,\n            force_field,\n            coords,\n            box_vectors,\n            equilibrate_config,\n            production_config,\n            [reporter],\n        )\n\n        # we can then compute the ensemble averages from the trajectory. generating\n        # the trajectory separately from computing the ensemble averages allows us\n        # to run the simulation in parallel with other simulations more easily, without\n        # having to worry about copying gradients between workers / processes.\n        avgs, stds = smee.mm.compute_ensemble_averages(\n            system, force_field, pathlib.Path(tmp_file.name), temperature, pressure\n        )\n        return avgs\n</pre> import pathlib  import torch   def compute_ensemble_averages(     system: smee.TensorSystem, force_field: smee.TensorForceField ) -&gt; dict[str, torch.Tensor]:     # computing the ensemble averages is a two step process - we first need to run     # an MD simulation using the force field making sure to store the coordinates,     # box vectors and kinetic energies     coords, box_vectors = smee.mm.generate_system_coords(system, force_field)      interval = 1000      # save the simulation output every 1000th frame (2 ps) to a temporary file.     # we could also save the trajectory more permanently, but as we do nothing     # with it after computing the averages in this example, we simply want to     # discard it.     with (         tempfile.NamedTemporaryFile() as tmp_file,         smee.mm.tensor_reporter(tmp_file.name, interval, beta, pressure) as reporter,     ):         smee.mm.simulate(             system,             force_field,             coords,             box_vectors,             equilibrate_config,             production_config,             [reporter],         )          # we can then compute the ensemble averages from the trajectory. generating         # the trajectory separately from computing the ensemble averages allows us         # to run the simulation in parallel with other simulations more easily, without         # having to worry about copying gradients between workers / processes.         avgs, stds = smee.mm.compute_ensemble_averages(             system, force_field, pathlib.Path(tmp_file.name), temperature, pressure         )         return avgs <p>Computing the ensemble averages is then as simple as:</p> In\u00a0[\u00a0]: Copied! <pre># run simulations of each system and compute ensemble averages over the trajectories\n# of the potential energy, volume, and density\nethanol_avgs = compute_ensemble_averages(system_ethanol, tensor_ff)\nmethanol_avgs = compute_ensemble_averages(system_methanol, tensor_ff)\nmixture_avgs = compute_ensemble_averages(system_mixture, tensor_ff)\n</pre> # run simulations of each system and compute ensemble averages over the trajectories # of the potential energy, volume, and density ethanol_avgs = compute_ensemble_averages(system_ethanol, tensor_ff) methanol_avgs = compute_ensemble_averages(system_methanol, tensor_ff) mixture_avgs = compute_ensemble_averages(system_mixture, tensor_ff) <p>Each of the returned values is a dictionary of ensemble averages computed over the simulated production trajectory. This currently includes the potential energy, volume, and density of the system.</p> <p>These averages can be used in a loss function</p> In\u00a0[\u00a0]: Copied! <pre># define some MOCK data and loss function\nmock_ethanol_density = 0.789  # g/mL\nmock_methanol_density = 0.791  # g/mL\n\nmock_enthalpy_of_mixing = 0.891  # kcal/mol\n\nloss = (ethanol_avgs[\"density\"] - mock_ethanol_density) ** 2\nloss += (methanol_avgs[\"density\"] - mock_methanol_density) ** 2\n\nmixture_enthalpy = mixture_avgs[\"enthalpy\"] / 256\n\nethanol_enthalpy = ethanol_avgs[\"enthalpy\"] / 128\nmethanol_enthalpy = methanol_avgs[\"enthalpy\"] / 128\n\nenthalpy_of_mixing = mixture_enthalpy - (\n    0.5 * ethanol_enthalpy + 0.5 * methanol_enthalpy\n)\nloss += (enthalpy_of_mixing - mock_enthalpy_of_mixing) ** 2\n</pre> # define some MOCK data and loss function mock_ethanol_density = 0.789  # g/mL mock_methanol_density = 0.791  # g/mL  mock_enthalpy_of_mixing = 0.891  # kcal/mol  loss = (ethanol_avgs[\"density\"] - mock_ethanol_density) ** 2 loss += (methanol_avgs[\"density\"] - mock_methanol_density) ** 2  mixture_enthalpy = mixture_avgs[\"enthalpy\"] / 256  ethanol_enthalpy = ethanol_avgs[\"enthalpy\"] / 128 methanol_enthalpy = methanol_avgs[\"enthalpy\"] / 128  enthalpy_of_mixing = mixture_enthalpy - (     0.5 * ethanol_enthalpy + 0.5 * methanol_enthalpy ) loss += (enthalpy_of_mixing - mock_enthalpy_of_mixing) ** 2 <p>and the gradient of this loss function with respect to the force field parameters can be computed through backpropagation:</p> In\u00a0[\u00a0]: Copied! <pre>loss.backward()\n\nepsilon_col = vdw_potential.parameter_cols.index(\"epsilon\")\nsigma_col = vdw_potential.parameter_cols.index(\"sigma\")\n\nprint(\"VdW \u0190 Gradients\", vdw_potential.parameters.grad[:, epsilon_col])\nprint(\"VdW \u03c3 Gradients\", vdw_potential.parameters.grad[:, sigma_col])\n</pre> loss.backward()  epsilon_col = vdw_potential.parameter_cols.index(\"epsilon\") sigma_col = vdw_potential.parameter_cols.index(\"sigma\")  print(\"VdW \u0190 Gradients\", vdw_potential.parameters.grad[:, epsilon_col]) print(\"VdW \u03c3 Gradients\", vdw_potential.parameters.grad[:, sigma_col])"},{"location":"examples/md-simulations/#ensemble-averages-from-md-simulations","title":"Ensemble Averages from MD Simulations\u00b6","text":"<p>This example shows how ensemble averages can be computed from MD simulations, such that their gradient with respect to force field parameters can be computed through backpropagation.</p> <p>We start by parameterizing the set of molecules that will appear in our simulation boxes:</p>"},{"location":"examples/parameter-gradients/","title":"Parameter Gradients","text":"In\u00a0[1]: Copied! <pre>import openff.interchange\nimport openff.toolkit\nimport openff.units\nimport torch\n\nimport smee.converters\n\nmolecule = openff.toolkit.Molecule.from_smiles(\"CC(=O)NC1=CC=C(C=C1)O\")\nmolecule.generate_conformers(n_conformers=1)\n\nconformer = torch.tensor(molecule.conformers[0].m_as(openff.units.unit.angstrom))\n\ninterchange = openff.interchange.Interchange.from_smirnoff(\n    openff.toolkit.ForceField(\"openff_unconstrained-2.0.0.offxml\"),\n    molecule.to_topology(),\n)\ntensor_ff, [tensor_topology] = smee.converters.convert_interchange(interchange)\n</pre> import openff.interchange import openff.toolkit import openff.units import torch  import smee.converters  molecule = openff.toolkit.Molecule.from_smiles(\"CC(=O)NC1=CC=C(C=C1)O\") molecule.generate_conformers(n_conformers=1)  conformer = torch.tensor(molecule.conformers[0].m_as(openff.units.unit.angstrom))  interchange = openff.interchange.Interchange.from_smirnoff(     openff.toolkit.ForceField(\"openff_unconstrained-2.0.0.offxml\"),     molecule.to_topology(), ) tensor_ff, [tensor_topology] = smee.converters.convert_interchange(interchange) <pre></pre> <p>We can access the parameters for each SMIRNOFF parameter 'handler' (e.g. vdW, bond, angle, etc.) using the <code>potentials_by_type</code> (or the <code>potentials</code>) attribute of the <code>TensorForceField</code> object.</p> In\u00a0[2]: Copied! <pre>vdw_potential = tensor_ff.potentials_by_type[\"vdW\"]\nvdw_potential.parameters.requires_grad = True\n</pre> vdw_potential = tensor_ff.potentials_by_type[\"vdW\"] vdw_potential.parameters.requires_grad = True <p>The gradient of the potential energy with respect to the parameters can then be computed by backpropagating through the energy computation.</p> In\u00a0[3]: Copied! <pre>import smee\n\nenergy = smee.compute_energy(tensor_topology, tensor_ff, conformer)\nenergy.backward()\n\nfor parameter_key, gradient in zip(\n    vdw_potential.parameter_keys, vdw_potential.parameters.grad.numpy()\n):\n    parameter_cols = vdw_potential.parameter_cols\n\n    parameter_grads = \", \".join(\n        f\"dU/d{parameter_col} = {parameter_grad: 8.3f}\"\n        for parameter_col, parameter_grad in zip(parameter_cols, gradient)\n    )\n    print(f\"{parameter_key.id.ljust(15)} - {parameter_grads}\")\n</pre> import smee  energy = smee.compute_energy(tensor_topology, tensor_ff, conformer) energy.backward()  for parameter_key, gradient in zip(     vdw_potential.parameter_keys, vdw_potential.parameters.grad.numpy() ):     parameter_cols = vdw_potential.parameter_cols      parameter_grads = \", \".join(         f\"dU/d{parameter_col} = {parameter_grad: 8.3f}\"         for parameter_col, parameter_grad in zip(parameter_cols, gradient)     )     print(f\"{parameter_key.id.ljust(15)} - {parameter_grads}\") <pre>[#6X4:1]        - dU/depsilon =   -1.033, dU/dsigma =   -0.139\n[#6:1]          - dU/depsilon =   87.490, dU/dsigma =   34.983\n[#8:1]          - dU/depsilon =   15.846, dU/dsigma =   17.232\n[#7:1]          - dU/depsilon =    0.148, dU/dsigma =    1.187\n[#8X2H1+0:1]    - dU/depsilon =   -0.305, dU/dsigma =    0.558\n[#1:1]-[#6X4]   - dU/depsilon =    7.630, dU/dsigma =    1.404\n[#1:1]-[#7]     - dU/depsilon =   -2.894, dU/dsigma =   -0.074\n[#1:1]-[#6X3]   - dU/depsilon =  137.134, dU/dsigma =   12.129\n[#1:1]-[#8]     - dU/depsilon =  -22.417, dU/dsigma =   -0.001\n</pre>"},{"location":"examples/parameter-gradients/#parameter-gradients","title":"Parameter Gradients\u00b6","text":"<p>This example will show how the gradient of the potential energy with respect to force field parameters may be computed.</p> <p>We start be loading and parameterizing the molecule of interest.</p>"},{"location":"reference/","title":"Index","text":""},{"location":"reference/#smee","title":"smee","text":"<p>smee</p> <p>Differentiably evaluate energies of molecules using SMIRNOFF force fields</p> <p>Modules:</p> <ul> <li> <code>converters</code>         \u2013          <p>Convert to / from SMEE tensor representations.</p> </li> <li> <code>geometry</code>         \u2013          <p>Compute internal coordinates (e.g. bond lengths).</p> </li> <li> <code>mm</code>         \u2013          <p>Compute differentiable ensemble averages using OpenMM and SMEE.</p> </li> <li> <code>potentials</code>         \u2013          <p>Evaluate the potential energy of parameterized topologies.</p> </li> <li> <code>tests</code>         \u2013          </li> <li> <code>utils</code>         \u2013          <p>General utility functions</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>NonbondedParameterMap</code>         \u2013          <p>A map between atom indices part of a particular valence interaction (e.g.</p> </li> <li> <code>TensorConstraints</code>         \u2013          <p>A tensor representation of a set of distance constraints between pairs of</p> </li> <li> <code>TensorForceField</code>         \u2013          <p>A tensor representation of a SMIRNOFF force field.</p> </li> <li> <code>TensorPotential</code>         \u2013          <p>A tensor representation of a valence SMIRNOFF parameter handler</p> </li> <li> <code>TensorSystem</code>         \u2013          <p>A tensor representation of a 'full' system.</p> </li> <li> <code>TensorTopology</code>         \u2013          <p>A tensor representation of a molecular topology that has been assigned force</p> </li> <li> <code>TensorVSites</code>         \u2013          <p>A tensor representation of a set of virtual sites parameters.</p> </li> <li> <code>ValenceParameterMap</code>         \u2013          <p>A map between atom indices part of a particular valence interaction (e.g.</p> </li> <li> <code>VSiteMap</code>         \u2013          <p>A map between virtual sites that have been added to a topology and their</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>add_v_site_coords</code>           \u2013            <p>Appends the coordinates of any virtual sites to a conformer (or batch of</p> </li> <li> <code>compute_v_site_coords</code>           \u2013            <p>Computes the positions of a set of virtual sites relative to a specified</p> </li> <li> <code>compute_energy</code>           \u2013            <p>Computes the potential energy [kcal / mol] of a system / topology in a given</p> </li> <li> <code>compute_energy_potential</code>           \u2013            <p>Computes the potential energy [kcal / mol] due to a SMIRNOFF potential</p> </li> </ul>"},{"location":"reference/#smee.NonbondedParameterMap","title":"NonbondedParameterMap  <code>dataclass</code>","text":"<p>A map between atom indices part of a particular valence interaction (e.g. torsion indices) and the corresponding parameter in a <code>TensorPotential</code></p> <p>Methods:</p> <ul> <li> <code>to</code>           \u2013            <p>Cast this object to the specified device.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>assignment_matrix</code>             (<code>Tensor</code>)         \u2013          <p>A sparse tensor that yields the parameters assigned to each particle in the</p> </li> <li> <code>exclusions</code>             (<code>Tensor</code>)         \u2013          <p>Indices of pairs of particles (i.e. atoms or virtual sites) that should</p> </li> <li> <code>exclusion_scale_idxs</code>             (<code>Tensor</code>)         \u2013          <p>Indices into the tensor of handler attributes defining the 1-n scaling factors</p> </li> </ul>"},{"location":"reference/#smee.NonbondedParameterMap.assignment_matrix","title":"assignment_matrix  <code>instance-attribute</code>","text":"<pre><code>assignment_matrix: Tensor\n</code></pre> <p>A sparse tensor that yields the parameters assigned to each particle in the system when multiplied with the corresponding handler parameters, with <code>shape=(n_particles, n_parameters)</code>.</p>"},{"location":"reference/#smee.NonbondedParameterMap.exclusions","title":"exclusions  <code>instance-attribute</code>","text":"<pre><code>exclusions: Tensor\n</code></pre> <p>Indices of pairs of particles (i.e. atoms or virtual sites) that should have their interactions scaled by some factor with <code>shape=(n_exclusions, 2)</code>.</p>"},{"location":"reference/#smee.NonbondedParameterMap.exclusion_scale_idxs","title":"exclusion_scale_idxs  <code>instance-attribute</code>","text":"<pre><code>exclusion_scale_idxs: Tensor\n</code></pre> <p>Indices into the tensor of handler attributes defining the 1-n scaling factors with <code>shape=(n_exclusions, 1)</code>.</p>"},{"location":"reference/#smee.NonbondedParameterMap.to","title":"to","text":"<pre><code>to(\n    device: DeviceType | None = None,\n    precision: Precision | None = None,\n) -&gt; NonbondedParameterMap\n</code></pre> <p>Cast this object to the specified device.</p> Source code in <code>smee/_models.py</code> <pre><code>def to(\n    self, device: DeviceType | None = None, precision: Precision | None = None\n) -&gt; \"NonbondedParameterMap\":\n    \"\"\"Cast this object to the specified device.\"\"\"\n    return NonbondedParameterMap(\n        _cast(self.assignment_matrix, device, precision),\n        _cast(self.exclusions, device, precision),\n        _cast(self.exclusion_scale_idxs, device, precision),\n    )\n</code></pre>"},{"location":"reference/#smee.TensorConstraints","title":"TensorConstraints  <code>dataclass</code>","text":"<p>A tensor representation of a set of distance constraints between pairs of atoms.</p> <p>Methods:</p> <ul> <li> <code>to</code>           \u2013            <p>Cast this object to the specified device.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>idxs</code>             (<code>Tensor</code>)         \u2013          <p>The indices of the atoms involved in each constraint with</p> </li> <li> <code>distances</code>             (<code>Tensor</code>)         \u2013          <p>The distance [\u00c5] between each pair of atoms with <code>shape=(n_constraints,)</code></p> </li> </ul>"},{"location":"reference/#smee.TensorConstraints.idxs","title":"idxs  <code>instance-attribute</code>","text":"<pre><code>idxs: Tensor\n</code></pre> <p>The indices of the atoms involved in each constraint with <code>shape=(n_constraints, 2)</code></p>"},{"location":"reference/#smee.TensorConstraints.distances","title":"distances  <code>instance-attribute</code>","text":"<pre><code>distances: Tensor\n</code></pre> <p>The distance [\u00c5] between each pair of atoms with <code>shape=(n_constraints,)</code></p>"},{"location":"reference/#smee.TensorConstraints.to","title":"to","text":"<pre><code>to(\n    device: DeviceType | None = None,\n    precision: Precision | None = None,\n) -&gt; TensorConstraints\n</code></pre> <p>Cast this object to the specified device.</p> Source code in <code>smee/_models.py</code> <pre><code>def to(\n    self, device: DeviceType | None = None, precision: Precision | None = None\n) -&gt; \"TensorConstraints\":\n    \"\"\"Cast this object to the specified device.\"\"\"\n    return TensorConstraints(\n        _cast(self.idxs, device, precision),\n        _cast(self.distances, device, precision),\n    )\n</code></pre>"},{"location":"reference/#smee.TensorForceField","title":"TensorForceField  <code>dataclass</code>","text":"<p>A tensor representation of a SMIRNOFF force field.</p> <p>Methods:</p> <ul> <li> <code>to</code>           \u2013            <p>Cast this object to the specified device.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>potentials</code>             (<code>list[TensorPotential]</code>)         \u2013          <p>The terms and associated parameters of the potential energy function.</p> </li> <li> <code>v_sites</code>             (<code>TensorVSites | None</code>)         \u2013          <p>Parameters used to add and define the coords of v-sites in the system. The</p> </li> </ul>"},{"location":"reference/#smee.TensorForceField.potentials","title":"potentials  <code>instance-attribute</code>","text":"<pre><code>potentials: list[TensorPotential]\n</code></pre> <p>The terms and associated parameters of the potential energy function.</p>"},{"location":"reference/#smee.TensorForceField.v_sites","title":"v_sites  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>v_sites: TensorVSites | None = None\n</code></pre> <p>Parameters used to add and define the coords of v-sites in the system. The non-bonded parameters of any v-sites are stored in relevant potentials, e.g. 'vdW' or 'Electrostatics'.</p>"},{"location":"reference/#smee.TensorForceField.to","title":"to","text":"<pre><code>to(\n    device: DeviceType | None = None,\n    precision: Precision | None = None,\n) -&gt; TensorForceField\n</code></pre> <p>Cast this object to the specified device.</p> Source code in <code>smee/_models.py</code> <pre><code>def to(\n    self, device: DeviceType | None = None, precision: Precision | None = None\n) -&gt; \"TensorForceField\":\n    \"\"\"Cast this object to the specified device.\"\"\"\n    return TensorForceField(\n        [potential.to(device, precision) for potential in self.potentials],\n        None if self.v_sites is None else self.v_sites.to(device, precision),\n    )\n</code></pre>"},{"location":"reference/#smee.TensorPotential","title":"TensorPotential  <code>dataclass</code>","text":"<p>A tensor representation of a valence SMIRNOFF parameter handler</p> <p>Methods:</p> <ul> <li> <code>to</code>           \u2013            <p>Cast this object to the specified device.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>type</code>             (<code>str</code>)         \u2013          <p>The type of handler associated with these parameters</p> </li> <li> <code>fn</code>             (<code>str</code>)         \u2013          <p>The associated potential energy function</p> </li> <li> <code>parameters</code>             (<code>Tensor</code>)         \u2013          <p>The values of the parameters with <code>shape=(n_parameters, n_parameter_cols)</code></p> </li> <li> <code>parameter_keys</code>             (<code>list[PotentialKey]</code>)         \u2013          <p>Unique keys associated with each parameter with <code>length=(n_parameters)</code></p> </li> <li> <code>parameter_cols</code>             (<code>tuple[str, ...]</code>)         \u2013          <p>The names of each column of <code>parameters</code>.</p> </li> <li> <code>parameter_units</code>             (<code>tuple[Unit, ...]</code>)         \u2013          <p>The units of each parameter in <code>parameters</code>.</p> </li> <li> <code>attributes</code>             (<code>Tensor | None</code>)         \u2013          <p>The attributes defined on a handler such as 1-4 scaling factors with</p> </li> <li> <code>attribute_cols</code>             (<code>tuple[str, ...] | None</code>)         \u2013          <p>The names of each column of <code>attributes</code>.</p> </li> <li> <code>attribute_units</code>             (<code>tuple[Unit, ...] | None</code>)         \u2013          <p>The units of each attribute in <code>attributes</code>.</p> </li> </ul>"},{"location":"reference/#smee.TensorPotential.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>The type of handler associated with these parameters</p>"},{"location":"reference/#smee.TensorPotential.fn","title":"fn  <code>instance-attribute</code>","text":"<pre><code>fn: str\n</code></pre> <p>The associated potential energy function</p>"},{"location":"reference/#smee.TensorPotential.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: Tensor\n</code></pre> <p>The values of the parameters with <code>shape=(n_parameters, n_parameter_cols)</code></p>"},{"location":"reference/#smee.TensorPotential.parameter_keys","title":"parameter_keys  <code>instance-attribute</code>","text":"<pre><code>parameter_keys: list[PotentialKey]\n</code></pre> <p>Unique keys associated with each parameter with <code>length=(n_parameters)</code></p>"},{"location":"reference/#smee.TensorPotential.parameter_cols","title":"parameter_cols  <code>instance-attribute</code>","text":"<pre><code>parameter_cols: tuple[str, ...]\n</code></pre> <p>The names of each column of <code>parameters</code>.</p>"},{"location":"reference/#smee.TensorPotential.parameter_units","title":"parameter_units  <code>instance-attribute</code>","text":"<pre><code>parameter_units: tuple[Unit, ...]\n</code></pre> <p>The units of each parameter in <code>parameters</code>.</p>"},{"location":"reference/#smee.TensorPotential.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: Tensor | None = None\n</code></pre> <p>The attributes defined on a handler such as 1-4 scaling factors with <code>shape=(n_attribute_cols,)</code></p>"},{"location":"reference/#smee.TensorPotential.attribute_cols","title":"attribute_cols  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attribute_cols: tuple[str, ...] | None = None\n</code></pre> <p>The names of each column of <code>attributes</code>.</p>"},{"location":"reference/#smee.TensorPotential.attribute_units","title":"attribute_units  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attribute_units: tuple[Unit, ...] | None = None\n</code></pre> <p>The units of each attribute in <code>attributes</code>.</p>"},{"location":"reference/#smee.TensorPotential.to","title":"to","text":"<pre><code>to(\n    device: DeviceType | None = None,\n    precision: Precision | None = None,\n) -&gt; TensorPotential\n</code></pre> <p>Cast this object to the specified device.</p> Source code in <code>smee/_models.py</code> <pre><code>def to(\n    self, device: DeviceType | None = None, precision: Precision | None = None\n) -&gt; \"TensorPotential\":\n    \"\"\"Cast this object to the specified device.\"\"\"\n    return TensorPotential(\n        self.type,\n        self.fn,\n        _cast(self.parameters, device, precision),\n        self.parameter_keys,\n        self.parameter_cols,\n        self.parameter_units,\n        (\n            None\n            if self.attributes is None\n            else _cast(self.attributes, device, precision)\n        ),\n        self.attribute_cols,\n        self.attribute_units,\n    )\n</code></pre>"},{"location":"reference/#smee.TensorSystem","title":"TensorSystem  <code>dataclass</code>","text":"<p>A tensor representation of a 'full' system.</p> <p>Methods:</p> <ul> <li> <code>to</code>           \u2013            <p>Cast this object to the specified device.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>topologies</code>             (<code>list[TensorTopology]</code>)         \u2013          <p>The topologies of the individual molecules in the system.</p> </li> <li> <code>n_copies</code>             (<code>list[int]</code>)         \u2013          <p>The number of copies of each topology to include in the system.</p> </li> <li> <code>is_periodic</code>             (<code>bool</code>)         \u2013          <p>Whether the system is periodic or not.</p> </li> <li> <code>n_atoms</code>             (<code>int</code>)         \u2013          <p>The number of atoms in the system.</p> </li> <li> <code>n_v_sites</code>             (<code>int</code>)         \u2013          <p>The number of v-sites in the system.</p> </li> <li> <code>n_particles</code>             (<code>int</code>)         \u2013          <p>The number of atoms + v-sites in the system.</p> </li> </ul>"},{"location":"reference/#smee.TensorSystem.topologies","title":"topologies  <code>instance-attribute</code>","text":"<pre><code>topologies: list[TensorTopology]\n</code></pre> <p>The topologies of the individual molecules in the system.</p>"},{"location":"reference/#smee.TensorSystem.n_copies","title":"n_copies  <code>instance-attribute</code>","text":"<pre><code>n_copies: list[int]\n</code></pre> <p>The number of copies of each topology to include in the system.</p>"},{"location":"reference/#smee.TensorSystem.is_periodic","title":"is_periodic  <code>instance-attribute</code>","text":"<pre><code>is_periodic: bool\n</code></pre> <p>Whether the system is periodic or not.</p>"},{"location":"reference/#smee.TensorSystem.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>The number of atoms in the system.</p>"},{"location":"reference/#smee.TensorSystem.n_v_sites","title":"n_v_sites  <code>property</code>","text":"<pre><code>n_v_sites: int\n</code></pre> <p>The number of v-sites in the system.</p>"},{"location":"reference/#smee.TensorSystem.n_particles","title":"n_particles  <code>property</code>","text":"<pre><code>n_particles: int\n</code></pre> <p>The number of atoms + v-sites in the system.</p>"},{"location":"reference/#smee.TensorSystem.to","title":"to","text":"<pre><code>to(\n    device: DeviceType | None = None,\n    precision: Precision | None = None,\n) -&gt; TensorSystem\n</code></pre> <p>Cast this object to the specified device.</p> Source code in <code>smee/_models.py</code> <pre><code>def to(\n    self, device: DeviceType | None = None, precision: Precision | None = None\n) -&gt; \"TensorSystem\":\n    \"\"\"Cast this object to the specified device.\"\"\"\n    return TensorSystem(\n        [topology.to(device, precision) for topology in self.topologies],\n        self.n_copies,\n        self.is_periodic,\n    )\n</code></pre>"},{"location":"reference/#smee.TensorTopology","title":"TensorTopology  <code>dataclass</code>","text":"<p>A tensor representation of a molecular topology that has been assigned force field parameters.</p> <p>Methods:</p> <ul> <li> <code>to</code>           \u2013            <p>Cast this object to the specified device.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>atomic_nums</code>             (<code>Tensor</code>)         \u2013          <p>The atomic numbers of each atom in the topology with <code>shape=(n_atoms,)</code></p> </li> <li> <code>formal_charges</code>             (<code>Tensor</code>)         \u2013          <p>The formal charge of each atom in the topology with <code>shape=(n_atoms,)</code></p> </li> <li> <code>bond_idxs</code>             (<code>Tensor</code>)         \u2013          <p>The indices of the atoms involved in each bond with <code>shape=(n_bonds, 2)</code></p> </li> <li> <code>bond_orders</code>             (<code>Tensor</code>)         \u2013          <p>The bond orders of each bond with <code>shape=(n_bonds,)</code></p> </li> <li> <code>parameters</code>             (<code>dict[str, ParameterMap]</code>)         \u2013          <p>The parameters that have been assigned to the topology.</p> </li> <li> <code>v_sites</code>             (<code>VSiteMap | None</code>)         \u2013          <p>The v-sites that have been assigned to the topology.</p> </li> <li> <code>constraints</code>             (<code>TensorConstraints | None</code>)         \u2013          <p>Distance constraints that should be applied during MD simulations. These</p> </li> <li> <code>n_atoms</code>             (<code>int</code>)         \u2013          <p>The number of atoms in the topology.</p> </li> <li> <code>n_bonds</code>             (<code>int</code>)         \u2013          <p>The number of bonds in the topology.</p> </li> <li> <code>n_v_sites</code>             (<code>int</code>)         \u2013          <p>The number of v-sites in the topology.</p> </li> <li> <code>n_particles</code>             (<code>int</code>)         \u2013          <p>The number of atoms + v-sites in the topology.</p> </li> </ul>"},{"location":"reference/#smee.TensorTopology.atomic_nums","title":"atomic_nums  <code>instance-attribute</code>","text":"<pre><code>atomic_nums: Tensor\n</code></pre> <p>The atomic numbers of each atom in the topology with <code>shape=(n_atoms,)</code></p>"},{"location":"reference/#smee.TensorTopology.formal_charges","title":"formal_charges  <code>instance-attribute</code>","text":"<pre><code>formal_charges: Tensor\n</code></pre> <p>The formal charge of each atom in the topology with <code>shape=(n_atoms,)</code></p>"},{"location":"reference/#smee.TensorTopology.bond_idxs","title":"bond_idxs  <code>instance-attribute</code>","text":"<pre><code>bond_idxs: Tensor\n</code></pre> <p>The indices of the atoms involved in each bond with <code>shape=(n_bonds, 2)</code></p>"},{"location":"reference/#smee.TensorTopology.bond_orders","title":"bond_orders  <code>instance-attribute</code>","text":"<pre><code>bond_orders: Tensor\n</code></pre> <p>The bond orders of each bond with <code>shape=(n_bonds,)</code></p>"},{"location":"reference/#smee.TensorTopology.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: dict[str, ParameterMap]\n</code></pre> <p>The parameters that have been assigned to the topology.</p>"},{"location":"reference/#smee.TensorTopology.v_sites","title":"v_sites  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>v_sites: VSiteMap | None = None\n</code></pre> <p>The v-sites that have been assigned to the topology.</p>"},{"location":"reference/#smee.TensorTopology.constraints","title":"constraints  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>constraints: TensorConstraints | None = None\n</code></pre> <p>Distance constraints that should be applied during MD simulations. These will not be used outside of MD simulations.</p>"},{"location":"reference/#smee.TensorTopology.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>The number of atoms in the topology.</p>"},{"location":"reference/#smee.TensorTopology.n_bonds","title":"n_bonds  <code>property</code>","text":"<pre><code>n_bonds: int\n</code></pre> <p>The number of bonds in the topology.</p>"},{"location":"reference/#smee.TensorTopology.n_v_sites","title":"n_v_sites  <code>property</code>","text":"<pre><code>n_v_sites: int\n</code></pre> <p>The number of v-sites in the topology.</p>"},{"location":"reference/#smee.TensorTopology.n_particles","title":"n_particles  <code>property</code>","text":"<pre><code>n_particles: int\n</code></pre> <p>The number of atoms + v-sites in the topology.</p>"},{"location":"reference/#smee.TensorTopology.to","title":"to","text":"<pre><code>to(\n    device: DeviceType | None = None,\n    precision: Precision | None = None,\n) -&gt; TensorTopology\n</code></pre> <p>Cast this object to the specified device.</p> Source code in <code>smee/_models.py</code> <pre><code>def to(\n    self, device: DeviceType | None = None, precision: Precision | None = None\n) -&gt; \"TensorTopology\":\n    \"\"\"Cast this object to the specified device.\"\"\"\n    return TensorTopology(\n        self.atomic_nums,\n        self.formal_charges,\n        self.bond_idxs,\n        self.bond_orders,\n        {k: v.to(device, precision) for k, v in self.parameters.items()},\n        None if self.v_sites is None else self.v_sites.to(device, precision),\n        (\n            None\n            if self.constraints is None\n            else self.constraints.to(device, precision)\n        ),\n    )\n</code></pre>"},{"location":"reference/#smee.TensorVSites","title":"TensorVSites  <code>dataclass</code>","text":"<p>A tensor representation of a set of virtual sites parameters.</p> <p>Methods:</p> <ul> <li> <code>default_units</code>           \u2013            <p>The default units of each v-site parameter.</p> </li> <li> <code>to</code>           \u2013            <p>Cast this object to the specified device.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>keys</code>             (<code>List[VirtualSiteKey]</code>)         \u2013          <p>The unique keys associated with each v-site with <code>length=(n_v_sites)</code></p> </li> <li> <code>weights</code>             (<code>list[Tensor]</code>)         \u2013          <p>A matrix of weights that, when applied to the 'orientiational' atoms, yields a</p> </li> <li> <code>parameters</code>             (<code>Tensor</code>)         \u2013          <p>The distance, in-plane and out-of-plane angles with <code>shape=(n_v_sites, 3)</code></p> </li> <li> <code>parameter_units</code>             (<code>dict[str, Unit]</code>)         \u2013          <p>The units of each v-site parameter.</p> </li> </ul>"},{"location":"reference/#smee.TensorVSites.keys","title":"keys  <code>instance-attribute</code>","text":"<pre><code>keys: List[VirtualSiteKey]\n</code></pre> <p>The unique keys associated with each v-site with <code>length=(n_v_sites)</code></p>"},{"location":"reference/#smee.TensorVSites.weights","title":"weights  <code>instance-attribute</code>","text":"<pre><code>weights: list[Tensor]\n</code></pre> <p>A matrix of weights that, when applied to the 'orientiational' atoms, yields a basis that the virtual site coordinate parameters can be projected onto with <code>shape=(n_v_sites, 3, 3)</code></p>"},{"location":"reference/#smee.TensorVSites.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: Tensor\n</code></pre> <p>The distance, in-plane and out-of-plane angles with <code>shape=(n_v_sites, 3)</code></p>"},{"location":"reference/#smee.TensorVSites.parameter_units","title":"parameter_units  <code>property</code>","text":"<pre><code>parameter_units: dict[str, Unit]\n</code></pre> <p>The units of each v-site parameter.</p>"},{"location":"reference/#smee.TensorVSites.default_units","title":"default_units  <code>classmethod</code>","text":"<pre><code>default_units() -&gt; dict[str, Unit]\n</code></pre> <p>The default units of each v-site parameter.</p> Source code in <code>smee/_models.py</code> <pre><code>@classmethod\ndef default_units(cls) -&gt; dict[str, openff.units.Unit]:\n    \"\"\"The default units of each v-site parameter.\"\"\"\n    return {\n        \"distance\": _ANGSTROM,\n        \"inPlaneAngle\": _RADIANS,\n        \"outOfPlaneAngle\": _RADIANS,\n    }\n</code></pre>"},{"location":"reference/#smee.TensorVSites.to","title":"to","text":"<pre><code>to(\n    device: DeviceType | None = None,\n    precision: Precision | None = None,\n) -&gt; TensorVSites\n</code></pre> <p>Cast this object to the specified device.</p> Source code in <code>smee/_models.py</code> <pre><code>def to(\n    self, device: DeviceType | None = None, precision: Precision | None = None\n) -&gt; \"TensorVSites\":\n    \"\"\"Cast this object to the specified device.\"\"\"\n    return TensorVSites(\n        self.keys,\n        [_cast(weight, device, precision) for weight in self.weights],\n        _cast(self.parameters, device, precision),\n    )\n</code></pre>"},{"location":"reference/#smee.ValenceParameterMap","title":"ValenceParameterMap  <code>dataclass</code>","text":"<p>A map between atom indices part of a particular valence interaction (e.g. torsion indices) and the corresponding parameter in a <code>TensorPotential</code></p> <p>Methods:</p> <ul> <li> <code>to</code>           \u2013            <p>Cast this object to the specified device.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>particle_idxs</code>             (<code>Tensor</code>)         \u2013          <p>The indices of the particles (e.g. atoms or virtual sites) involved in an</p> </li> <li> <code>assignment_matrix</code>             (<code>Tensor</code>)         \u2013          <p>A sparse tensor that yields the assigned parameters when multiplied with the</p> </li> </ul>"},{"location":"reference/#smee.ValenceParameterMap.particle_idxs","title":"particle_idxs  <code>instance-attribute</code>","text":"<pre><code>particle_idxs: Tensor\n</code></pre> <p>The indices of the particles (e.g. atoms or virtual sites) involved in an interaction with <code>shape=(n_interactions, n_cols)</code>. For a bond <code>n_cols=2</code>, for angles <code>n_cols=3</code> etc.</p>"},{"location":"reference/#smee.ValenceParameterMap.assignment_matrix","title":"assignment_matrix  <code>instance-attribute</code>","text":"<pre><code>assignment_matrix: Tensor\n</code></pre> <p>A sparse tensor that yields the assigned parameters when multiplied with the corresponding handler parameters, with <code>shape=(n_interacting, n_parameters)</code>.</p>"},{"location":"reference/#smee.ValenceParameterMap.to","title":"to","text":"<pre><code>to(\n    device: DeviceType | None = None,\n    precision: Precision | None = None,\n) -&gt; ValenceParameterMap\n</code></pre> <p>Cast this object to the specified device.</p> Source code in <code>smee/_models.py</code> <pre><code>def to(\n    self, device: DeviceType | None = None, precision: Precision | None = None\n) -&gt; \"ValenceParameterMap\":\n    \"\"\"Cast this object to the specified device.\"\"\"\n    return ValenceParameterMap(\n        _cast(self.particle_idxs, device, precision),\n        _cast(self.assignment_matrix, device, precision),\n    )\n</code></pre>"},{"location":"reference/#smee.VSiteMap","title":"VSiteMap  <code>dataclass</code>","text":"<p>A map between virtual sites that have been added to a topology and their corresponding 'parameters' used to position them.</p> <p>Methods:</p> <ul> <li> <code>to</code>           \u2013            <p>Cast this object to the specified device.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>keys</code>             (<code>list[VirtualSiteKey]</code>)         \u2013          <p>The keys used to identify each v-site.</p> </li> <li> <code>key_to_idx</code>             (<code>dict[VirtualSiteKey, int]</code>)         \u2013          <p>A map between the unique keys associated with each v-site and their index in</p> </li> <li> <code>parameter_idxs</code>             (<code>Tensor</code>)         \u2013          <p>The indices of the corresponding v-site parameters with <code>shape=(n_v_sites, 1)</code></p> </li> </ul>"},{"location":"reference/#smee.VSiteMap.keys","title":"keys  <code>instance-attribute</code>","text":"<pre><code>keys: list[VirtualSiteKey]\n</code></pre> <p>The keys used to identify each v-site.</p>"},{"location":"reference/#smee.VSiteMap.key_to_idx","title":"key_to_idx  <code>instance-attribute</code>","text":"<pre><code>key_to_idx: dict[VirtualSiteKey, int]\n</code></pre> <p>A map between the unique keys associated with each v-site and their index in the topology</p>"},{"location":"reference/#smee.VSiteMap.parameter_idxs","title":"parameter_idxs  <code>instance-attribute</code>","text":"<pre><code>parameter_idxs: Tensor\n</code></pre> <p>The indices of the corresponding v-site parameters with <code>shape=(n_v_sites, 1)</code></p>"},{"location":"reference/#smee.VSiteMap.to","title":"to","text":"<pre><code>to(\n    device: DeviceType | None = None,\n    precision: Precision | None = None,\n) -&gt; VSiteMap\n</code></pre> <p>Cast this object to the specified device.</p> Source code in <code>smee/_models.py</code> <pre><code>def to(\n    self, device: DeviceType | None = None, precision: Precision | None = None\n) -&gt; \"VSiteMap\":\n    \"\"\"Cast this object to the specified device.\"\"\"\n    return VSiteMap(\n        self.keys, self.key_to_idx, _cast(self.parameter_idxs, device, precision)\n    )\n</code></pre>"},{"location":"reference/#smee.add_v_site_coords","title":"add_v_site_coords","text":"<pre><code>add_v_site_coords(\n    v_sites: VSiteMap,\n    conformer: Tensor,\n    force_field: TensorForceField,\n) -&gt; Tensor\n</code></pre> <p>Appends the coordinates of any virtual sites to a conformer (or batch of conformers) containing only atomic coordinates.</p> Notes <ul> <li>This function only supports appending v-sites to the end of the list of   coordinates, and not interleaving them between existing atomic coordinates.</li> </ul> <p>Parameters:</p> <ul> <li> <code>v_sites</code>             (<code>VSiteMap</code>)         \u2013          <p>A mapping between the virtual sites to add and their corresponding force field parameters.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer(s) to add the virtual sites to with <code>shape=(n_atoms, 3)</code> or <code>shape=(n_batches, n_atoms, 3)</code> and units of [\u00c5].</p> </li> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field containing the virtual site parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The full conformer(s) with both atomic and virtual site coordinates [\u00c5] with <code>shape=(n_atoms+n_v_sites, 3)</code> or <code>shape=(n_batches, n_atoms+n_v_sites, 3)</code>.</p> </li> </ul> Source code in <code>smee/geometry.py</code> <pre><code>def add_v_site_coords(\n    v_sites: \"smee.VSiteMap\",\n    conformer: torch.Tensor,\n    force_field: \"smee.TensorForceField\",\n) -&gt; torch.Tensor:\n    \"\"\"Appends the coordinates of any virtual sites to a conformer (or batch of\n    conformers) containing only atomic coordinates.\n\n    Notes:\n        * This function only supports appending v-sites to the end of the list of\n          coordinates, and not interleaving them between existing atomic coordinates.\n\n    Args:\n        v_sites: A mapping between the virtual sites to add and their corresponding\n            force field parameters.\n        conformer: The conformer(s) to add the virtual sites to with\n            ``shape=(n_atoms, 3)`` or ``shape=(n_batches, n_atoms, 3)`` and units of\n            [\u00c5].\n        force_field: The force field containing the virtual site parameters.\n\n    Returns:\n        The full conformer(s) with both atomic and virtual site coordinates [\u00c5] with\n        ``shape=(n_atoms+n_v_sites, 3)`` or ``shape=(n_batches, n_atoms+n_v_sites, 3)``.\n    \"\"\"\n\n    v_site_coords = compute_v_site_coords(v_sites, conformer, force_field)\n\n    return torch.cat([conformer, v_site_coords], dim=(1 if conformer.ndim == 3 else 0))\n</code></pre>"},{"location":"reference/#smee.compute_v_site_coords","title":"compute_v_site_coords","text":"<pre><code>compute_v_site_coords(\n    v_sites: VSiteMap,\n    conformer: Tensor,\n    force_field: TensorForceField,\n) -&gt; Tensor\n</code></pre> <p>Computes the positions of a set of virtual sites relative to a specified conformer or batch of conformers.</p> <p>Parameters:</p> <ul> <li> <code>v_sites</code>             (<code>VSiteMap</code>)         \u2013          <p>A mapping between the virtual sites to add and their corresponding force field parameters.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer(s) to add the virtual sites to with <code>shape=(n_atoms, 3)</code> or <code>shape=(n_batches, n_atoms, 3)</code> and units of [\u00c5].</p> </li> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field containing the virtual site parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>A tensor of virtual site positions [\u00c5] with <code>shape=(n_v_sites, 3)</code> or <code>shape=(n_batches, n_v_sites, 3)</code>.</p> </li> </ul> Source code in <code>smee/geometry.py</code> <pre><code>def compute_v_site_coords(\n    v_sites: \"smee.VSiteMap\",\n    conformer: torch.Tensor,\n    force_field: \"smee.TensorForceField\",\n) -&gt; torch.Tensor:\n    \"\"\"Computes the positions of a set of virtual sites relative to a specified\n    conformer or batch of conformers.\n\n    Args:\n        v_sites: A mapping between the virtual sites to add and their corresponding\n            force field parameters.\n        conformer: The conformer(s) to add the virtual sites to with\n            ``shape=(n_atoms, 3)`` or ``shape=(n_batches, n_atoms, 3)`` and units of\n            [\u00c5].\n        force_field: The force field containing the virtual site parameters.\n\n    Returns:\n        A tensor of virtual site positions [\u00c5] with ``shape=(n_v_sites, 3)`` or\n        ``shape=(n_batches, n_v_sites, 3)``.\n    \"\"\"\n\n    is_batched = conformer.ndim == 3\n\n    if not is_batched:\n        conformer = torch.unsqueeze(conformer, 0)\n\n    if len(v_sites.parameter_idxs) &gt; 0:\n        local_frame_coords = force_field.v_sites.parameters[v_sites.parameter_idxs]\n        local_coord_frames = _build_v_site_coord_frames(v_sites, conformer, force_field)\n\n        v_site_coords = _convert_v_site_coords(local_frame_coords, local_coord_frames)\n    else:\n        v_site_coords = smee.utils.zeros_like((len(conformer), 0, 3), other=conformer)\n\n    if not is_batched:\n        v_site_coords = torch.squeeze(v_site_coords, 0)\n\n    return v_site_coords\n</code></pre>"},{"location":"reference/#smee.compute_energy","title":"compute_energy","text":"<pre><code>compute_energy(\n    system: TensorSystem | TensorTopology,\n    force_field: TensorForceField,\n    conformer: Tensor,\n    box_vectors: Tensor | None = None,\n) -&gt; Tensor\n</code></pre> <p>Computes the potential energy [kcal / mol] of a system / topology in a given conformation(s).</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem | TensorTopology</code>)         \u2013          <p>The system or topology to compute the potential energy of.</p> </li> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field that defines the potential energy function.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer(s) to evaluate the potential at with <code>shape=(n_particles, 3)</code> or <code>shape=(n_confs, n_particles, 3)</code>.</p> </li> <li> <code>box_vectors</code>             (<code>Tensor | None</code>, default:                 <code>None</code> )         \u2013          <p>The box vectors of the system with <code>shape=(3, 3)</code> if the system is periodic, or <code>None</code> if the system is non-periodic.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The potential energy of the conformer(s) [kcal / mol].</p> </li> </ul> Source code in <code>smee/potentials/_potentials.py</code> <pre><code>def compute_energy(\n    system: smee.TensorSystem | smee.TensorTopology,\n    force_field: smee.TensorForceField,\n    conformer: torch.Tensor,\n    box_vectors: torch.Tensor | None = None,\n) -&gt; torch.Tensor:\n    \"\"\"Computes the potential energy [kcal / mol] of a system / topology in a given\n    conformation(s).\n\n    Args:\n        system: The system or topology to compute the potential energy of.\n        force_field: The force field that defines the potential energy function.\n        conformer: The conformer(s) to evaluate the potential at with\n            ``shape=(n_particles, 3)`` or ``shape=(n_confs, n_particles, 3)``.\n        box_vectors: The box vectors of the system with ``shape=(3, 3)`` if the\n            system is periodic, or ``None`` if the system is non-periodic.\n\n    Returns:\n        The potential energy of the conformer(s) [kcal / mol].\n    \"\"\"\n\n    # register the built-in potential energy functions\n    importlib.import_module(\"smee.potentials.nonbonded\")\n    importlib.import_module(\"smee.potentials.valence\")\n\n    system, conformer, box_vectors = _prepare_inputs(system, conformer, box_vectors)\n    pairwise = _precompute_pairwise(system, force_field, conformer, box_vectors)\n\n    energy = smee.utils.zeros_like(\n        conformer.shape[0] if conformer.ndim == 3 else 1, conformer\n    )\n\n    for potential in force_field.potentials:\n        energy += compute_energy_potential(\n            system, potential, conformer, box_vectors, pairwise\n        )\n\n    return energy\n</code></pre>"},{"location":"reference/#smee.compute_energy_potential","title":"compute_energy_potential","text":"<pre><code>compute_energy_potential(\n    system: TensorSystem | TensorTopology,\n    potential: TensorPotential,\n    conformer: Tensor,\n    box_vectors: Tensor | None = None,\n    pairwise: Optional[PairwiseDistances] = None,\n) -&gt; Tensor\n</code></pre> <p>Computes the potential energy [kcal / mol] due to a SMIRNOFF potential handler for a given conformer(s).</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem | TensorTopology</code>)         \u2013          <p>The system or topology to compute the potential energy of.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential describing the energy function to compute.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer(s) to evaluate the potential at with <code>shape=(n_particles, 3)</code> or <code>shape=(n_confs, n_particles, 3)</code>.</p> </li> <li> <code>box_vectors</code>             (<code>Tensor | None</code>, default:                 <code>None</code> )         \u2013          <p>The box vectors of the system with <code>shape=(3, 3)</code> or shape=(n_confs, 3, 3)<code>if the system is periodic, or</code>None`` if the system is non-periodic.</p> </li> <li> <code>pairwise</code>             (<code>Optional[PairwiseDistances]</code>, default:                 <code>None</code> )         \u2013          <p>Pre-computed pairwise distances between particles in the system.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The potential energy of the conformer(s) [kcal / mol].</p> </li> </ul> Source code in <code>smee/potentials/_potentials.py</code> <pre><code>def compute_energy_potential(\n    system: smee.TensorSystem | smee.TensorTopology,\n    potential: smee.TensorPotential,\n    conformer: torch.Tensor,\n    box_vectors: torch.Tensor | None = None,\n    pairwise: typing.Optional[\"smee.potentials.nonbonded.PairwiseDistances\"] = None,\n) -&gt; torch.Tensor:\n    \"\"\"Computes the potential energy [kcal / mol] due to a SMIRNOFF potential\n    handler for a given conformer(s).\n\n    Args:\n        system: The system or topology to compute the potential energy of.\n        potential: The potential describing the energy function to compute.\n        conformer: The conformer(s) to evaluate the potential at with\n            ``shape=(n_particles, 3)`` or ``shape=(n_confs, n_particles, 3)``.\n        box_vectors: The box vectors of the system with ``shape=(3, 3)`` or\n            shape=(n_confs, 3, 3)`` if the system is periodic, or ``None`` if the system\n            is non-periodic.\n        pairwise: Pre-computed pairwise distances between particles in the system.\n\n    Returns:\n        The potential energy of the conformer(s) [kcal / mol].\n    \"\"\"\n\n    # register the built-in potential energy functions\n    importlib.import_module(\"smee.potentials.nonbonded\")\n    importlib.import_module(\"smee.potentials.valence\")\n\n    system, conformer, box_vectors = _prepare_inputs(system, conformer, box_vectors)\n\n    energy_fn = _POTENTIAL_ENERGY_FUNCTIONS[(potential.type, potential.fn)]\n    energy_fn_spec = inspect.signature(energy_fn)\n\n    energy_fn_kwargs = {}\n\n    if \"box_vectors\" in energy_fn_spec.parameters:\n        energy_fn_kwargs[\"box_vectors\"] = box_vectors\n    if \"pairwise\" in energy_fn_spec.parameters:\n        energy_fn_kwargs[\"pairwise\"] = pairwise\n\n    return energy_fn(system, potential, conformer, **energy_fn_kwargs)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> smee<ul> <li> converters<ul> <li> openff<ul> <li> nonbonded</li> <li> valence</li> </ul> </li> <li> openmm</li> </ul> </li> <li> geometry</li> <li> mm</li> <li> potentials<ul> <li> nonbonded</li> <li> valence</li> </ul> </li> <li> utils</li> </ul> </li> </ul>"},{"location":"reference/geometry/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> geometry","text":""},{"location":"reference/geometry/#smee.geometry","title":"geometry","text":"<p>Compute internal coordinates (e.g. bond lengths).</p> <p>Functions:</p> <ul> <li> <code>compute_bond_vectors</code>           \u2013            <p>Computes the vectors between each atom pair specified by the <code>atom_indices</code> as</p> </li> <li> <code>compute_angles</code>           \u2013            <p>Computes the angles [rad] between each atom triplet specified by the</p> </li> <li> <code>compute_dihedrals</code>           \u2013            <p>Computes the dihedral angles [rad] between each atom quartet specified by the</p> </li> <li> <code>polar_to_cartesian_coords</code>           \u2013            <p>Converts a set of polar coordinates into cartesian coordinates.</p> </li> <li> <code>compute_v_site_coords</code>           \u2013            <p>Computes the positions of a set of virtual sites relative to a specified</p> </li> <li> <code>add_v_site_coords</code>           \u2013            <p>Appends the coordinates of any virtual sites to a conformer (or batch of</p> </li> </ul>"},{"location":"reference/geometry/#smee.geometry.compute_bond_vectors","title":"compute_bond_vectors","text":"<pre><code>compute_bond_vectors(\n    conformer: Tensor, atom_indices: Tensor\n) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Computes the vectors between each atom pair specified by the <code>atom_indices</code> as well as their norms.</p> <p>Parameters:</p> <ul> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to compute the bond vectors for with <code>shape=(n_atoms, 3)</code> or <code>shape=(n_confs, n_atoms, 3)</code>.</p> </li> <li> <code>atom_indices</code>             (<code>Tensor</code>)         \u2013          <p>The indices of the atoms involved in each bond with <code>shape=(n_bonds, 2)</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Tensor, Tensor]</code>         \u2013          <p>The bond vectors and their norms [\u00c5].</p> </li> </ul> Source code in <code>smee/geometry.py</code> <pre><code>def compute_bond_vectors(\n    conformer: torch.Tensor, atom_indices: torch.Tensor\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"Computes the vectors between each atom pair specified by the ``atom_indices`` as\n    well as their norms.\n\n    Args:\n        conformer: The conformer [\u00c5] to compute the bond vectors for with\n            ``shape=(n_atoms, 3)`` or ``shape=(n_confs, n_atoms, 3)``.\n        atom_indices: The indices of the atoms involved in each bond with\n            ``shape=(n_bonds, 2)``\n\n    Returns:\n        The bond vectors and their norms [\u00c5].\n    \"\"\"\n\n    if len(atom_indices) == 0:\n        return (\n            smee.utils.tensor_like([], other=conformer),\n            smee.utils.tensor_like([], other=conformer),\n        )\n\n    is_batched = conformer.ndim == 3\n\n    if not is_batched:\n        conformer = torch.unsqueeze(conformer, 0)\n\n    directions = conformer[:, atom_indices[:, 1]] - conformer[:, atom_indices[:, 0]]\n    distances = torch.norm(directions, dim=-1)\n\n    if not is_batched:\n        directions = torch.squeeze(directions, dim=0)\n        distances = torch.squeeze(distances, dim=0)\n\n    return directions, distances\n</code></pre>"},{"location":"reference/geometry/#smee.geometry.compute_angles","title":"compute_angles","text":"<pre><code>compute_angles(\n    conformer: Tensor, atom_indices: Tensor\n) -&gt; Tensor\n</code></pre> <p>Computes the angles [rad] between each atom triplet specified by the <code>atom_indices</code>.</p> <p>Parameters:</p> <ul> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to compute the angles for with <code>shape=(n_atoms, 3)</code> or <code>shape=(n_confs, n_atoms, 3)</code>.</p> </li> <li> <code>atom_indices</code>             (<code>Tensor</code>)         \u2013          <p>The indices of the atoms involved in each angle with <code>shape=(n_angles, 3)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The valence angles [rad].</p> </li> </ul> Source code in <code>smee/geometry.py</code> <pre><code>def compute_angles(conformer: torch.Tensor, atom_indices: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Computes the angles [rad] between each atom triplet specified by the\n    ``atom_indices``.\n\n    Args:\n        conformer: The conformer [\u00c5] to compute the angles for with\n            ``shape=(n_atoms, 3)`` or ``shape=(n_confs, n_atoms, 3)``.\n        atom_indices: The indices of the atoms involved in each angle with\n            ``shape=(n_angles, 3)``.\n\n    Returns:\n        The valence angles [rad].\n    \"\"\"\n\n    if len(atom_indices) == 0:\n        return smee.utils.tensor_like([], other=conformer)\n\n    is_batched = conformer.ndim == 3\n\n    if not is_batched:\n        conformer = torch.unsqueeze(conformer, 0)\n\n    vector_ab = conformer[:, atom_indices[:, 1]] - conformer[:, atom_indices[:, 0]]\n    vector_ac = conformer[:, atom_indices[:, 1]] - conformer[:, atom_indices[:, 2]]\n\n    # tan theta = sin theta / cos theta\n    #\n    # ||a x b|| = ||a|| ||b|| sin theta\n    #   a . b   = ||a|| ||b|| cos theta\n    #\n    # =&gt; tan theta = (a x b) / (a . b)\n    angles = torch.atan2(\n        torch.norm(torch.cross(vector_ab, vector_ac, dim=-1), dim=-1),\n        (vector_ab * vector_ac).sum(dim=-1),\n    )\n\n    if not is_batched:\n        angles = torch.squeeze(angles, dim=0)\n\n    return angles\n</code></pre>"},{"location":"reference/geometry/#smee.geometry.compute_dihedrals","title":"compute_dihedrals","text":"<pre><code>compute_dihedrals(\n    conformer: Tensor, atom_indices: Tensor\n) -&gt; Tensor\n</code></pre> <p>Computes the dihedral angles [rad] between each atom quartet specified by the <code>atom_indices</code>.</p> <p>Parameters:</p> <ul> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to compute the dihedral angles for with <code>shape=(n_atoms, 3)</code> or <code>shape=(n_confs, n_atoms, 3)</code>.</p> </li> <li> <code>atom_indices</code>             (<code>Tensor</code>)         \u2013          <p>The indices of the atoms involved in each dihedral angle with <code>shape=(n_dihedrals, 4)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The dihedral angles [rad].</p> </li> </ul> Source code in <code>smee/geometry.py</code> <pre><code>def compute_dihedrals(\n    conformer: torch.Tensor, atom_indices: torch.Tensor\n) -&gt; torch.Tensor:\n    \"\"\"Computes the dihedral angles [rad] between each atom quartet specified by the\n    ``atom_indices``.\n\n    Args:\n        conformer: The conformer [\u00c5] to compute the dihedral angles for with\n            ``shape=(n_atoms, 3)`` or ``shape=(n_confs, n_atoms, 3)``.\n        atom_indices: The indices of the atoms involved in each dihedral angle with\n            ``shape=(n_dihedrals, 4)``.\n\n    Returns:\n        The dihedral angles [rad].\n    \"\"\"\n\n    if len(atom_indices) == 0:\n        return smee.utils.tensor_like([], other=conformer)\n\n    is_batched = conformer.ndim == 3\n\n    if not is_batched:\n        conformer = torch.unsqueeze(conformer, 0)\n\n    # Based on the OpenMM formalism.\n    vector_ab = conformer[:, atom_indices[:, 0]] - conformer[:, atom_indices[:, 1]]\n    vector_cb = conformer[:, atom_indices[:, 2]] - conformer[:, atom_indices[:, 1]]\n    vector_cd = conformer[:, atom_indices[:, 2]] - conformer[:, atom_indices[:, 3]]\n\n    vector_ab_cross_cb = torch.cross(vector_ab, vector_cb, dim=-1)\n    vector_cb_cross_cd = torch.cross(vector_cb, vector_cd, dim=-1)\n\n    vector_cb_norm = torch.norm(vector_cb, dim=-1).unsqueeze(-1)\n\n    y = (\n        torch.cross(vector_ab_cross_cb, vector_cb_cross_cd, dim=-1)\n        * vector_cb\n        / vector_cb_norm\n    ).sum(axis=-1)\n\n    x = (vector_ab_cross_cb * vector_cb_cross_cd).sum(axis=-1)\n\n    phi = torch.atan2(y, x)\n\n    if not is_batched:\n        phi = torch.squeeze(phi, dim=0)\n\n    return phi\n</code></pre>"},{"location":"reference/geometry/#smee.geometry.polar_to_cartesian_coords","title":"polar_to_cartesian_coords","text":"<pre><code>polar_to_cartesian_coords(polar_coords: Tensor) -&gt; Tensor\n</code></pre> <p>Converts a set of polar coordinates into cartesian coordinates.</p> <p>Parameters:</p> <ul> <li> <code>polar_coords</code>             (<code>Tensor</code>)         \u2013          <p>The polar coordinates with <code>shape=(n_coords, 3)</code> and with columns of distance [\u00c5], 'in plane angle' [rad] and 'out of plane' angle [rad].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>An array of the cartesian coordinates with <code>shape=(n_coords, 3)</code> and units of [\u00c5].</p> </li> </ul> Source code in <code>smee/geometry.py</code> <pre><code>def polar_to_cartesian_coords(polar_coords: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Converts a set of polar coordinates into cartesian coordinates.\n\n    Args:\n        polar_coords: The polar coordinates with ``shape=(n_coords, 3)`` and with\n            columns of distance [\u00c5], 'in plane angle' [rad] and 'out of plane'\n            angle [rad].\n\n    Returns:\n        An array of the cartesian coordinates with ``shape=(n_coords, 3)`` and units\n        of [\u00c5].\n    \"\"\"\n\n    d, theta, phi = polar_coords[:, 0], polar_coords[:, 1], polar_coords[:, 2]\n\n    cos_theta = torch.cos(theta)\n    sin_theta = torch.sin(theta)\n\n    cos_phi = torch.cos(phi)\n    sin_phi = torch.sin(phi)\n\n    # Here we use cos(phi) in place of sin(phi) and sin(phi) in place of cos(phi)\n    # this is because we want phi=0 to represent a 0 degree angle from the x-y plane\n    # rather than 0 degrees from the z-axis.\n    coords = torch.stack(\n        [d * cos_theta * cos_phi, d * sin_theta * cos_phi, d * sin_phi], dim=-1\n    )\n    return coords\n</code></pre>"},{"location":"reference/geometry/#smee.geometry.compute_v_site_coords","title":"compute_v_site_coords","text":"<pre><code>compute_v_site_coords(\n    v_sites: VSiteMap,\n    conformer: Tensor,\n    force_field: TensorForceField,\n) -&gt; Tensor\n</code></pre> <p>Computes the positions of a set of virtual sites relative to a specified conformer or batch of conformers.</p> <p>Parameters:</p> <ul> <li> <code>v_sites</code>             (<code>VSiteMap</code>)         \u2013          <p>A mapping between the virtual sites to add and their corresponding force field parameters.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer(s) to add the virtual sites to with <code>shape=(n_atoms, 3)</code> or <code>shape=(n_batches, n_atoms, 3)</code> and units of [\u00c5].</p> </li> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field containing the virtual site parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>A tensor of virtual site positions [\u00c5] with <code>shape=(n_v_sites, 3)</code> or <code>shape=(n_batches, n_v_sites, 3)</code>.</p> </li> </ul> Source code in <code>smee/geometry.py</code> <pre><code>def compute_v_site_coords(\n    v_sites: \"smee.VSiteMap\",\n    conformer: torch.Tensor,\n    force_field: \"smee.TensorForceField\",\n) -&gt; torch.Tensor:\n    \"\"\"Computes the positions of a set of virtual sites relative to a specified\n    conformer or batch of conformers.\n\n    Args:\n        v_sites: A mapping between the virtual sites to add and their corresponding\n            force field parameters.\n        conformer: The conformer(s) to add the virtual sites to with\n            ``shape=(n_atoms, 3)`` or ``shape=(n_batches, n_atoms, 3)`` and units of\n            [\u00c5].\n        force_field: The force field containing the virtual site parameters.\n\n    Returns:\n        A tensor of virtual site positions [\u00c5] with ``shape=(n_v_sites, 3)`` or\n        ``shape=(n_batches, n_v_sites, 3)``.\n    \"\"\"\n\n    is_batched = conformer.ndim == 3\n\n    if not is_batched:\n        conformer = torch.unsqueeze(conformer, 0)\n\n    if len(v_sites.parameter_idxs) &gt; 0:\n        local_frame_coords = force_field.v_sites.parameters[v_sites.parameter_idxs]\n        local_coord_frames = _build_v_site_coord_frames(v_sites, conformer, force_field)\n\n        v_site_coords = _convert_v_site_coords(local_frame_coords, local_coord_frames)\n    else:\n        v_site_coords = smee.utils.zeros_like((len(conformer), 0, 3), other=conformer)\n\n    if not is_batched:\n        v_site_coords = torch.squeeze(v_site_coords, 0)\n\n    return v_site_coords\n</code></pre>"},{"location":"reference/geometry/#smee.geometry.add_v_site_coords","title":"add_v_site_coords","text":"<pre><code>add_v_site_coords(\n    v_sites: VSiteMap,\n    conformer: Tensor,\n    force_field: TensorForceField,\n) -&gt; Tensor\n</code></pre> <p>Appends the coordinates of any virtual sites to a conformer (or batch of conformers) containing only atomic coordinates.</p> Notes <ul> <li>This function only supports appending v-sites to the end of the list of   coordinates, and not interleaving them between existing atomic coordinates.</li> </ul> <p>Parameters:</p> <ul> <li> <code>v_sites</code>             (<code>VSiteMap</code>)         \u2013          <p>A mapping between the virtual sites to add and their corresponding force field parameters.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer(s) to add the virtual sites to with <code>shape=(n_atoms, 3)</code> or <code>shape=(n_batches, n_atoms, 3)</code> and units of [\u00c5].</p> </li> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field containing the virtual site parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The full conformer(s) with both atomic and virtual site coordinates [\u00c5] with <code>shape=(n_atoms+n_v_sites, 3)</code> or <code>shape=(n_batches, n_atoms+n_v_sites, 3)</code>.</p> </li> </ul> Source code in <code>smee/geometry.py</code> <pre><code>def add_v_site_coords(\n    v_sites: \"smee.VSiteMap\",\n    conformer: torch.Tensor,\n    force_field: \"smee.TensorForceField\",\n) -&gt; torch.Tensor:\n    \"\"\"Appends the coordinates of any virtual sites to a conformer (or batch of\n    conformers) containing only atomic coordinates.\n\n    Notes:\n        * This function only supports appending v-sites to the end of the list of\n          coordinates, and not interleaving them between existing atomic coordinates.\n\n    Args:\n        v_sites: A mapping between the virtual sites to add and their corresponding\n            force field parameters.\n        conformer: The conformer(s) to add the virtual sites to with\n            ``shape=(n_atoms, 3)`` or ``shape=(n_batches, n_atoms, 3)`` and units of\n            [\u00c5].\n        force_field: The force field containing the virtual site parameters.\n\n    Returns:\n        The full conformer(s) with both atomic and virtual site coordinates [\u00c5] with\n        ``shape=(n_atoms+n_v_sites, 3)`` or ``shape=(n_batches, n_atoms+n_v_sites, 3)``.\n    \"\"\"\n\n    v_site_coords = compute_v_site_coords(v_sites, conformer, force_field)\n\n    return torch.cat([conformer, v_site_coords], dim=(1 if conformer.ndim == 3 else 0))\n</code></pre>"},{"location":"reference/utils/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> utils","text":""},{"location":"reference/utils/#smee.utils","title":"utils","text":"<p>General utility functions</p> <p>Functions:</p> <ul> <li> <code>find_exclusions</code>           \u2013            <p>Find all excluded interaction pairs and their associated scaling factor.</p> </li> <li> <code>ones_like</code>           \u2013            <p>Create a tensor of ones with the same device and type as another tensor.</p> </li> <li> <code>zeros_like</code>           \u2013            <p>Create a tensor of zeros with the same device and type as another tensor.</p> </li> <li> <code>tensor_like</code>           \u2013            <p>Create a tensor with the same device and type as another tensor.</p> </li> <li> <code>arange_like</code>           \u2013            <p>Arange a tensor with the same device and type as another tensor.</p> </li> <li> <code>logsumexp</code>           \u2013            <p>Compute the log of the sum of the exponential of the input elements, optionally</p> </li> <li> <code>to_upper_tri_idx</code>           \u2013            <p>Converts pairs of 2D indices to 1D indices in an upper triangular matrix that</p> </li> <li> <code>geometric_mean</code>           \u2013            <p>Computes the geometric mean of two values 'safely'.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>EPSILON</code>         \u2013          <p>A small epsilon value used to prevent divide by zero errors.</p> </li> </ul>"},{"location":"reference/utils/#smee.utils.EPSILON","title":"EPSILON  <code>module-attribute</code>","text":"<pre><code>EPSILON = 1e-06\n</code></pre> <p>A small epsilon value used to prevent divide by zero errors.</p>"},{"location":"reference/utils/#smee.utils.find_exclusions","title":"find_exclusions","text":"<pre><code>find_exclusions(\n    topology: Topology, v_sites: Optional[VSiteMap] = None\n) -&gt; dict[tuple[int, int], ExclusionType]\n</code></pre> <p>Find all excluded interaction pairs and their associated scaling factor.</p> <p>Parameters:</p> <ul> <li> <code>topology</code>             (<code>Topology</code>)         \u2013          <p>The topology to find the interaction pairs of.</p> </li> <li> <code>v_sites</code>             (<code>Optional[VSiteMap]</code>, default:                 <code>None</code> )         \u2013          <p>Virtual sites that will be added to the topology.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A dictionary of the form ``{(atom_idx_1, atom_idx_2</code>         \u2013          <p>scale}``.</p> </li> </ul> Source code in <code>smee/utils.py</code> <pre><code>def find_exclusions(\n    topology: openff.toolkit.Topology,\n    v_sites: typing.Optional[\"smee.VSiteMap\"] = None,\n) -&gt; dict[tuple[int, int], ExclusionType]:\n    \"\"\"Find all excluded interaction pairs and their associated scaling factor.\n\n    Args:\n        topology: The topology to find the interaction pairs of.\n        v_sites: Virtual sites that will be added to the topology.\n\n    Returns:\n        A dictionary of the form ``{(atom_idx_1, atom_idx_2): scale}``.\n    \"\"\"\n\n    graph = networkx.from_edgelist(\n        tuple(\n            sorted((topology.atom_index(bond.atom1), topology.atom_index(bond.atom2)))\n        )\n        for bond in topology.bonds\n    )\n\n    if v_sites is not None:\n\n        for v_site_key in v_sites.keys:\n            v_site_idx = v_sites.key_to_idx[v_site_key]\n            parent_idx = v_site_key.orientation_atom_indices[0]\n\n            for neighbour_idx in graph.neighbors(parent_idx):\n                graph.add_edge(v_site_idx, neighbour_idx)\n\n            graph.add_edge(v_site_idx, parent_idx)\n\n    distances = dict(networkx.all_pairs_shortest_path_length(graph, cutoff=5))\n    distance_to_scale = {1: \"scale_12\", 2: \"scale_13\", 3: \"scale_14\", 4: \"scale_15\"}\n\n    exclusions = {}\n\n    for idx_a in distances:\n        for idx_b, distance in distances[idx_a].items():\n            pair = tuple(sorted((idx_a, idx_b)))\n            scale = distance_to_scale.get(distance)\n\n            if scale is None:\n                continue\n\n            assert pair not in exclusions or exclusions[pair] == scale\n            exclusions[pair] = scale\n\n    return exclusions\n</code></pre>"},{"location":"reference/utils/#smee.utils.ones_like","title":"ones_like","text":"<pre><code>ones_like(size: _size, other: Tensor) -&gt; Tensor\n</code></pre> <p>Create a tensor of ones with the same device and type as another tensor.</p> Source code in <code>smee/utils.py</code> <pre><code>def ones_like(size: _size, other: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Create a tensor of ones with the same device and type as another tensor.\"\"\"\n    return torch.ones(size, dtype=other.dtype, device=other.device)\n</code></pre>"},{"location":"reference/utils/#smee.utils.zeros_like","title":"zeros_like","text":"<pre><code>zeros_like(size: _size, other: Tensor) -&gt; Tensor\n</code></pre> <p>Create a tensor of zeros with the same device and type as another tensor.</p> Source code in <code>smee/utils.py</code> <pre><code>def zeros_like(size: _size, other: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Create a tensor of zeros with the same device and type as another tensor.\"\"\"\n    return torch.zeros(size, dtype=other.dtype, device=other.device)\n</code></pre>"},{"location":"reference/utils/#smee.utils.tensor_like","title":"tensor_like","text":"<pre><code>tensor_like(data: Any, other: Tensor) -&gt; Tensor\n</code></pre> <p>Create a tensor with the same device and type as another tensor.</p> Source code in <code>smee/utils.py</code> <pre><code>def tensor_like(data: typing.Any, other: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Create a tensor with the same device and type as another tensor.\"\"\"\n\n    if isinstance(data, torch.Tensor):\n        return data.clone().detach().to(other.device, other.dtype)\n\n    return torch.tensor(data, dtype=other.dtype, device=other.device)\n</code></pre>"},{"location":"reference/utils/#smee.utils.arange_like","title":"arange_like","text":"<pre><code>arange_like(end: int, other: Tensor) -&gt; Tensor\n</code></pre> <p>Arange a tensor with the same device and type as another tensor.</p> Source code in <code>smee/utils.py</code> <pre><code>def arange_like(end: int, other: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Arange a tensor with the same device and type as another tensor.\"\"\"\n    return torch.arange(end, dtype=other.dtype, device=other.device)\n</code></pre>"},{"location":"reference/utils/#smee.utils.logsumexp","title":"logsumexp","text":"<pre><code>logsumexp(\n    a: Tensor,\n    dim: int,\n    keepdim: bool = False,\n    b: Tensor | None = None,\n    return_sign: bool = False,\n) -&gt; Tensor | tuple[Tensor, Tensor]\n</code></pre> <p>Compute the log of the sum of the exponential of the input elements, optionally with each element multiplied by a scaling factor.</p> Notes <p>This should be removed if torch.logsumexp is updated to support scaling factors.</p> <p>Parameters:</p> <ul> <li> <code>a</code>             (<code>Tensor</code>)         \u2013          <p>The elements that should be summed over.</p> </li> <li> <code>dim</code>             (<code>int</code>)         \u2013          <p>The dimension to sum over.</p> </li> <li> <code>keepdim</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to keep the summed dimension.</p> </li> <li> <code>b</code>             (<code>Tensor | None</code>, default:                 <code>None</code> )         \u2013          <p>The scaling factor to multiply each element by.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor | tuple[Tensor, Tensor]</code>         \u2013          <p>The log of the sum of exponential of the a elements.</p> </li> </ul> Source code in <code>smee/utils.py</code> <pre><code>def logsumexp(\n    a: torch.Tensor,\n    dim: int,\n    keepdim: bool = False,\n    b: torch.Tensor | None = None,\n    return_sign: bool = False,\n) -&gt; torch.Tensor | tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"Compute the log of the sum of the exponential of the input elements, optionally\n    with each element multiplied by a scaling factor.\n\n    Notes:\n        This should be removed if torch.logsumexp is updated to support scaling factors.\n\n    Args:\n        a: The elements that should be summed over.\n        dim: The dimension to sum over.\n        keepdim: Whether to keep the summed dimension.\n        b: The scaling factor to multiply each element by.\n\n    Returns:\n        The log of the sum of exponential of the a elements.\n    \"\"\"\n    a_type = a.dtype\n\n    if b is None:\n        assert return_sign is False\n        return torch.logsumexp(a, dim, keepdim)\n\n    a = a.double()\n    b = b if b is not None else b.double()\n\n    a, b = torch.broadcast_tensors(a, b)\n\n    if torch.any(b == 0):\n        a[b == 0] = -torch.inf\n\n    a_max = torch.amax(a, dim=dim, keepdim=True)\n\n    if a_max.ndim &gt; 0:\n        a_max[~torch.isfinite(a_max)] = 0\n    elif not torch.isfinite(a_max):\n        a_max = 0\n\n    exp_sum = torch.sum(b * torch.exp(a - a_max), dim=dim, keepdim=keepdim)\n    sign = None\n\n    if return_sign:\n        sign = torch.sign(exp_sum)\n        exp_sum = exp_sum * sign\n\n    ln_exp_sum = torch.log(exp_sum)\n\n    if not keepdim:\n        a_max = torch.squeeze(a_max, dim=dim)\n\n    ln_exp_sum += a_max\n    ln_exp_sum = ln_exp_sum.to(a_type)\n\n    if return_sign:\n        return ln_exp_sum, sign.to(a_type)\n    else:\n        return ln_exp_sum\n</code></pre>"},{"location":"reference/utils/#smee.utils.to_upper_tri_idx","title":"to_upper_tri_idx","text":"<pre><code>to_upper_tri_idx(i: Tensor, j: Tensor, n: int) -&gt; Tensor\n</code></pre> <p>Converts pairs of 2D indices to 1D indices in an upper triangular matrix that excludes the diagonal.</p> <p>Parameters:</p> <ul> <li> <code>i</code>             (<code>Tensor</code>)         \u2013          <p>A tensor of the indices along the first axis with <code>shape=(n_pairs,)</code>.</p> </li> <li> <code>j</code>             (<code>Tensor</code>)         \u2013          <p>A tensor of the indices along the second axis with <code>shape=(n_pairs,)</code>.</p> </li> <li> <code>n</code>             (<code>int</code>)         \u2013          <p>The size of the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>A tensor of the indices in the upper triangular matrix with <code>shape=(n_pairs * (n_pairs - 1) // 2,)</code>.</p> </li> </ul> Source code in <code>smee/utils.py</code> <pre><code>def to_upper_tri_idx(i: torch.Tensor, j: torch.Tensor, n: int) -&gt; torch.Tensor:\n    \"\"\"Converts pairs of 2D indices to 1D indices in an upper triangular matrix that\n    excludes the diagonal.\n\n    Args:\n        i: A tensor of the indices along the first axis with ``shape=(n_pairs,)``.\n        j: A tensor of the indices along the second axis with ``shape=(n_pairs,)``.\n        n: The size of the matrix.\n\n    Returns:\n        A tensor of the indices in the upper triangular matrix with\n        ``shape=(n_pairs * (n_pairs - 1) // 2,)``.\n    \"\"\"\n    assert (i &lt; j).all(), \"i must be less than j\"\n    return (i * (2 * n - i - 1)) // 2 + j - i - 1\n</code></pre>"},{"location":"reference/utils/#smee.utils.geometric_mean","title":"geometric_mean","text":"<pre><code>geometric_mean(eps_a: Tensor, eps_b: Tensor) -&gt; Tensor\n</code></pre> <p>Computes the geometric mean of two values 'safely'.</p> <p>A small epsilon (<code>smee.utils.EPSILON</code>) is added when computing the gradient in cases where the mean is zero to prevent divide by zero errors.</p> <p>Parameters:</p> <ul> <li> <code>eps_a</code>             (<code>Tensor</code>)         \u2013          <p>The first value.</p> </li> <li> <code>eps_b</code>             (<code>Tensor</code>)         \u2013          <p>The second value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The geometric mean of the two values.</p> </li> </ul> Source code in <code>smee/utils.py</code> <pre><code>def geometric_mean(eps_a: torch.Tensor, eps_b: torch.Tensor) -&gt; torch.Tensor:\n    \"\"\"Computes the geometric mean of two values 'safely'.\n\n    A small epsilon (``smee.utils.EPSILON``) is added when computing the gradient in\n    cases where the mean is zero to prevent divide by zero errors.\n\n    Args:\n        eps_a: The first value.\n        eps_b: The second value.\n\n    Returns:\n        The geometric mean of the two values.\n    \"\"\"\n\n    return _SafeGeometricMean.apply(eps_a, eps_b)\n</code></pre>"},{"location":"reference/converters/","title":"Index","text":""},{"location":"reference/converters/#smee.converters","title":"converters","text":"<p>Convert to / from SMEE tensor representations.</p> <p>Modules:</p> <ul> <li> <code>openff</code>         \u2013          <p>Tensor representations of SMIRNOFF force fields.</p> </li> <li> <code>openmm</code>         \u2013          <p>Convert tensor representations into OpenMM systems.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>convert_handlers</code>           \u2013            <p>Convert a set of SMIRNOFF parameter handlers into a set of tensor potentials.</p> </li> <li> <code>convert_interchange</code>           \u2013            <p>Convert a list of interchange objects into tensor potentials.</p> </li> <li> <code>smirnoff_parameter_converter</code>           \u2013            <p>A decorator used to flag a function as being able to convert a parameter handlers</p> </li> <li> <code>convert_to_openmm_system</code>           \u2013            <p>Convert a SMEE force field and system / topology into an OpenMM system.</p> </li> <li> <code>convert_to_openmm_topology</code>           \u2013            <p>Convert a SMEE system to an OpenMM topology.</p> </li> </ul>"},{"location":"reference/converters/#smee.converters.convert_handlers","title":"convert_handlers","text":"<pre><code>convert_handlers(\n    handlers: list[SMIRNOFFCollection],\n    topologies: list[Topology],\n    v_site_maps: list[VSiteMap | None] | None = None,\n) -&gt; tuple[TensorPotential, list[ParameterMap]]\n</code></pre> <p>Convert a set of SMIRNOFF parameter handlers into a set of tensor potentials.</p> <p>Parameters:</p> <ul> <li> <code>handlers</code>             (<code>list[SMIRNOFFCollection]</code>)         \u2013          <p>The SMIRNOFF parameter handler collections for a set of interchange objects to convert.</p> </li> <li> <code>topologies</code>             (<code>list[Topology]</code>)         \u2013          <p>The topologies associated with each interchange object.</p> </li> <li> <code>v_site_maps</code>             (<code>list[VSiteMap | None] | None</code>, default:                 <code>None</code> )         \u2013          <p>The v-site maps associated with each interchange object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[TensorPotential, list[ParameterMap]]</code>         \u2013          <p>The potential containing the values of the parameters in each handler collection, and a list of maps (one per topology) between molecule elements (e.g. bond indices) and parameter indices.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from openff.toolkit import ForceField, Molecule\n&gt;&gt;&gt; from openff.interchange import Interchange\n&gt;&gt;&gt;\n&gt;&gt;&gt; force_field = ForceField(\"openff_unconstrained-2.0.0.offxml\")\n&gt;&gt;&gt; molecules = [Molecule.from_smiles(\"CCO\"), Molecule.from_smiles(\"CC\")]\n&gt;&gt;&gt;\n&gt;&gt;&gt; interchanges = [\n...     Interchange.from_smirnoff(force_field, molecule.to_topology())\n...     for molecule in molecules\n... ]\n&gt;&gt;&gt; vdw_handlers = [\n...     interchange.collections[\"vdW\"] for interchange in interchanges\n... ]\n&gt;&gt;&gt;\n&gt;&gt;&gt; vdw_potential, applied_vdw_parameters = convert_handlers(interchanges)\n</code></pre> Source code in <code>smee/converters/openff/_openff.py</code> <pre><code>def convert_handlers(\n    handlers: list[openff.interchange.smirnoff.SMIRNOFFCollection],\n    topologies: list[openff.toolkit.Topology],\n    v_site_maps: list[smee.VSiteMap | None] | None = None,\n) -&gt; tuple[smee.TensorPotential, list[smee.ParameterMap]]:\n    \"\"\"Convert a set of SMIRNOFF parameter handlers into a set of tensor potentials.\n\n    Args:\n        handlers: The SMIRNOFF parameter handler collections for a set of interchange\n            objects to convert.\n        topologies: The topologies associated with each interchange object.\n        v_site_maps: The v-site maps associated with each interchange object.\n\n    Returns:\n        The potential containing the values of the parameters in each handler\n        collection, and a list of maps (one per topology) between molecule elements\n        (e.g. bond indices) and parameter indices.\n\n\n    Examples:\n\n        &gt;&gt;&gt; from openff.toolkit import ForceField, Molecule\n        &gt;&gt;&gt; from openff.interchange import Interchange\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; force_field = ForceField(\"openff_unconstrained-2.0.0.offxml\")\n        &gt;&gt;&gt; molecules = [Molecule.from_smiles(\"CCO\"), Molecule.from_smiles(\"CC\")]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; interchanges = [\n        ...     Interchange.from_smirnoff(force_field, molecule.to_topology())\n        ...     for molecule in molecules\n        ... ]\n        &gt;&gt;&gt; vdw_handlers = [\n        ...     interchange.collections[\"vdW\"] for interchange in interchanges\n        ... ]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vdw_potential, applied_vdw_parameters = convert_handlers(interchanges)\n    \"\"\"\n    handler_types = {handler.type for handler in handlers}\n    assert len(handler_types) == 1, \"multiple handler types found\"\n    handler_type = next(iter(handler_types))\n\n    assert len(handlers) == len(topologies), \"mismatched number of topologies\"\n\n    importlib.import_module(\"smee.converters.openff.nonbonded\")\n    importlib.import_module(\"smee.converters.openff.valence\")\n\n    if handler_type not in _CONVERTERS:\n        raise NotImplementedError(f\"{handler_type} handlers is not yet supported.\")\n\n    converter = _CONVERTERS[handler_type]\n    converter_spec = inspect.signature(converter)\n\n    converter_kwargs = {}\n\n    if \"topologies\" in converter_spec.parameters:\n        converter_kwargs[\"topologies\"] = topologies\n    if \"v_site_maps\" in converter_spec.parameters:\n        assert v_site_maps is not None, \"v-site maps must be provided\"\n        converter_kwargs[\"v_site_maps\"] = v_site_maps\n\n    return converter(handlers, **converter_kwargs)\n</code></pre>"},{"location":"reference/converters/#smee.converters.convert_interchange","title":"convert_interchange","text":"<pre><code>convert_interchange(\n    interchange: Interchange | list[Interchange],\n) -&gt; tuple[TensorForceField, list[TensorTopology]]\n</code></pre> <p>Convert a list of interchange objects into tensor potentials.</p> <p>Parameters:</p> <ul> <li> <code>interchange</code>             (<code>Interchange | list[Interchange]</code>)         \u2013          <p>The list of (or singile) interchange objects to convert into tensor potentials.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[TensorForceField, list[TensorTopology]]</code>         \u2013          <p>The tensor force field containing the parameters of each handler, and a list (one per interchange) of objects mapping molecule elements (e.g. bonds, angles) to corresponding handler parameters.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from openff.toolkit import ForceField, Molecule\n&gt;&gt;&gt; from openff.interchange import Interchange\n&gt;&gt;&gt;\n&gt;&gt;&gt; force_field = ForceField(\"openff_unconstrained-2.0.0.offxml\")\n&gt;&gt;&gt; molecules = [Molecule.from_smiles(\"CCO\"), Molecule.from_smiles(\"CC\")]\n&gt;&gt;&gt;\n&gt;&gt;&gt; interchanges = [\n...     Interchange.from_smirnoff(force_field, molecule.to_topology())\n...     for molecule in molecules\n... ]\n&gt;&gt;&gt;\n&gt;&gt;&gt; tensor_ff, tensor_topologies = convert_interchange(interchanges)\n</code></pre> Source code in <code>smee/converters/openff/_openff.py</code> <pre><code>def convert_interchange(\n    interchange: openff.interchange.Interchange | list[openff.interchange.Interchange],\n) -&gt; tuple[smee.TensorForceField, list[smee.TensorTopology]]:\n    \"\"\"Convert a list of interchange objects into tensor potentials.\n\n    Args:\n        interchange: The list of (or singile) interchange objects to convert into\n            tensor potentials.\n\n    Returns:\n        The tensor force field containing the parameters of each handler, and a list\n        (one per interchange) of objects mapping molecule elements (e.g. bonds, angles)\n        to corresponding handler parameters.\n\n    Examples:\n\n        &gt;&gt;&gt; from openff.toolkit import ForceField, Molecule\n        &gt;&gt;&gt; from openff.interchange import Interchange\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; force_field = ForceField(\"openff_unconstrained-2.0.0.offxml\")\n        &gt;&gt;&gt; molecules = [Molecule.from_smiles(\"CCO\"), Molecule.from_smiles(\"CC\")]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; interchanges = [\n        ...     Interchange.from_smirnoff(force_field, molecule.to_topology())\n        ...     for molecule in molecules\n        ... ]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; tensor_ff, tensor_topologies = convert_interchange(interchanges)\n    \"\"\"\n    interchanges = (\n        [interchange]\n        if isinstance(interchange, openff.interchange.Interchange)\n        else interchange\n    )\n    topologies = []\n\n    handler_types = {\n        handler_type\n        for interchange in interchanges\n        for handler_type in interchange.collections\n    }\n    handlers_by_type = {handler_type: [] for handler_type in sorted(handler_types)}\n\n    for interchange in interchanges:\n        for handler_type in handlers_by_type:\n            handler = (\n                None\n                if handler_type not in interchange.collections\n                else interchange.collections[handler_type]\n            )\n            handlers_by_type[handler_type].append(handler)\n\n        topologies.append(interchange.topology)\n\n    v_sites, v_site_maps = None, [None] * len(topologies)\n\n    if \"VirtualSites\" in handlers_by_type:\n        v_sites, v_site_maps = _convert_v_sites(\n            handlers_by_type.pop(\"VirtualSites\"), topologies\n        )\n\n    constraints = [None] * len(topologies)\n\n    if \"Constraints\" in handlers_by_type:\n        constraints = _convert_constraints(handlers_by_type.pop(\"Constraints\"))\n\n    potentials, parameter_maps_by_handler = [], {}\n\n    for handler_type, handlers in handlers_by_type.items():\n        if (\n            sum(len(handler.potentials) for handler in handlers if handler is not None)\n            == 0\n        ):\n            continue\n\n        potential, parameter_map = convert_handlers(handlers, topologies, v_site_maps)\n        potentials.append(potential)\n\n        parameter_maps_by_handler[potential.type] = parameter_map\n\n    tensor_topologies = [\n        _convert_topology(\n            topology,\n            {\n                potential.type: parameter_maps_by_handler[potential.type][i]\n                for potential in potentials\n            },\n            v_site_maps[i],\n            constraints[i],\n        )\n        for i, topology in enumerate(topologies)\n    ]\n\n    tensor_force_field = smee.TensorForceField(potentials, v_sites)\n    return tensor_force_field, tensor_topologies\n</code></pre>"},{"location":"reference/converters/#smee.converters.smirnoff_parameter_converter","title":"smirnoff_parameter_converter","text":"<pre><code>smirnoff_parameter_converter(\n    type_: str, default_units: dict[str, Unit]\n)\n</code></pre> <p>A decorator used to flag a function as being able to convert a parameter handlers parameters into tensors.</p> <p>Parameters:</p> <ul> <li> <code>type_</code>             (<code>str</code>)         \u2013          <p>The type of parameter handler that the decorated function can convert.</p> </li> <li> <code>default_units</code>             (<code>dict[str, Unit]</code>)         \u2013          <p>The default units of each parameter in the handler.</p> </li> </ul> Source code in <code>smee/converters/openff/_openff.py</code> <pre><code>def smirnoff_parameter_converter(\n    type_: str, default_units: dict[str, openff.units.Unit]\n):\n    \"\"\"A decorator used to flag a function as being able to convert a parameter handlers\n    parameters into tensors.\n\n    Args:\n        type_: The type of parameter handler that the decorated function can convert.\n        default_units: The default units of each parameter in the handler.\n    \"\"\"\n\n    def parameter_converter_inner(func):\n        if type_ in _CONVERTERS:\n            raise KeyError(f\"A {type_} converter is already registered.\")\n\n        _CONVERTERS[type_] = func\n        _DEFAULT_UNITS[type_] = default_units\n\n        return func\n\n    return parameter_converter_inner\n</code></pre>"},{"location":"reference/converters/#smee.converters.convert_to_openmm_system","title":"convert_to_openmm_system","text":"<pre><code>convert_to_openmm_system(\n    force_field: TensorForceField,\n    system: TensorSystem | TensorTopology,\n) -&gt; System\n</code></pre> <p>Convert a SMEE force field and system / topology into an OpenMM system.</p> <p>Parameters:</p> <ul> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field parameters.</p> </li> <li> <code>system</code>             (<code>TensorSystem | TensorTopology</code>)         \u2013          <p>The system / topology to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>System</code>         \u2013          <p>The OpenMM system.</p> </li> </ul> Source code in <code>smee/converters/openmm.py</code> <pre><code>def convert_to_openmm_system(\n    force_field: smee.TensorForceField,\n    system: smee.TensorSystem | smee.TensorTopology,\n) -&gt; openmm.System:\n    \"\"\"Convert a SMEE force field and system / topology into an OpenMM system.\n\n    Args:\n        force_field: The force field parameters.\n        system: The system / topology to convert.\n\n    Returns:\n        The OpenMM system.\n    \"\"\"\n\n    system: smee.TensorSystem = (\n        system\n        if isinstance(system, smee.TensorSystem)\n        else smee.TensorSystem([system], [1], False)\n    )\n\n    force_field = force_field.to(\"cpu\")\n    system = system.to(\"cpu\")\n\n    omm_forces = {\n        potential_type: convert_to_openmm_force(potential, system)\n        for potential_type, potential in force_field.potentials_by_type.items()\n    }\n    omm_system = create_openmm_system(system, force_field.v_sites)\n\n    if (\n        \"Electrostatics\" in omm_forces\n        and \"vdW\" in omm_forces\n        and len(omm_forces[\"vdW\"]) == 1\n        and isinstance(omm_forces[\"vdW\"][0], openmm.NonbondedForce)\n    ):\n        (electrostatic_force,) = omm_forces.pop(\"Electrostatics\")\n        (vdw_force,) = omm_forces.pop(\"vdW\")\n\n        nonbonded_force = _combine_nonbonded(vdw_force, electrostatic_force)\n        omm_system.addForce(nonbonded_force)\n\n    for forces in omm_forces.values():\n        for force in forces:\n            omm_system.addForce(force)\n\n    _apply_constraints(omm_system, system)\n\n    return omm_system\n</code></pre>"},{"location":"reference/converters/#smee.converters.convert_to_openmm_topology","title":"convert_to_openmm_topology","text":"<pre><code>convert_to_openmm_topology(\n    system: TensorSystem,\n) -&gt; Topology\n</code></pre> <p>Convert a SMEE system to an OpenMM topology.</p> Source code in <code>smee/converters/openmm.py</code> <pre><code>def convert_to_openmm_topology(system: smee.TensorSystem) -&gt; openmm.app.Topology:\n    \"\"\"Convert a SMEE system to an OpenMM topology.\"\"\"\n    omm_topology = openmm.app.Topology()\n\n    for topology, n_copies in zip(system.topologies, system.n_copies):\n        chain = omm_topology.addChain()\n\n        is_water = topology.n_atoms == 3 and sorted(\n            int(v) for v in topology.atomic_nums\n        ) == [1, 1, 8]\n\n        residue_name = \"WAT\" if is_water else \"UNK\"\n\n        for _ in range(n_copies):\n            residue = omm_topology.addResidue(residue_name, chain)\n            element_counter = collections.defaultdict(int)\n\n            atoms = {}\n\n            for i, atomic_num in enumerate(topology.atomic_nums):\n                element = openmm.app.Element.getByAtomicNumber(int(atomic_num))\n                element_counter[element.symbol] += 1\n\n                name = element.symbol + (\n                    \"\"\n                    if element_counter[element.symbol] == 1 and element.symbol != \"H\"\n                    else f\"{element_counter[element.symbol]}\"\n                )\n                atoms[i] = omm_topology.addAtom(name, element, residue)\n\n            for i in range(topology.n_v_sites):\n                omm_topology.addAtom(\n                    \"X\", openmm.app.Element.getByAtomicNumber(82), residue\n                )\n\n            for bond_idxs, bond_order in zip(topology.bond_idxs, topology.bond_orders):\n                idx_a, idx_b = int(bond_idxs[0]), int(bond_idxs[1])\n\n                bond_order = int(bond_order)\n                bond_type = {\n                    1: openmm.app.Single,\n                    2: openmm.app.Double,\n                    3: openmm.app.Triple,\n                }[bond_order]\n\n                omm_topology.addBond(atoms[idx_a], atoms[idx_b], bond_type, bond_order)\n\n    return omm_topology\n</code></pre>"},{"location":"reference/converters/openmm/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> openmm","text":""},{"location":"reference/converters/openmm/#smee.converters.openmm","title":"openmm","text":"<p>Convert tensor representations into OpenMM systems.</p> <p>Functions:</p> <ul> <li> <code>convert_to_openmm_system</code>           \u2013            <p>Convert a SMEE force field and system / topology into an OpenMM system.</p> </li> <li> <code>convert_to_openmm_topology</code>           \u2013            <p>Convert a SMEE system to an OpenMM topology.</p> </li> </ul>"},{"location":"reference/converters/openmm/#smee.converters.openmm.convert_to_openmm_system","title":"convert_to_openmm_system","text":"<pre><code>convert_to_openmm_system(\n    force_field: TensorForceField,\n    system: TensorSystem | TensorTopology,\n) -&gt; System\n</code></pre> <p>Convert a SMEE force field and system / topology into an OpenMM system.</p> <p>Parameters:</p> <ul> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field parameters.</p> </li> <li> <code>system</code>             (<code>TensorSystem | TensorTopology</code>)         \u2013          <p>The system / topology to convert.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>System</code>         \u2013          <p>The OpenMM system.</p> </li> </ul> Source code in <code>smee/converters/openmm.py</code> <pre><code>def convert_to_openmm_system(\n    force_field: smee.TensorForceField,\n    system: smee.TensorSystem | smee.TensorTopology,\n) -&gt; openmm.System:\n    \"\"\"Convert a SMEE force field and system / topology into an OpenMM system.\n\n    Args:\n        force_field: The force field parameters.\n        system: The system / topology to convert.\n\n    Returns:\n        The OpenMM system.\n    \"\"\"\n\n    system: smee.TensorSystem = (\n        system\n        if isinstance(system, smee.TensorSystem)\n        else smee.TensorSystem([system], [1], False)\n    )\n\n    force_field = force_field.to(\"cpu\")\n    system = system.to(\"cpu\")\n\n    omm_forces = {\n        potential_type: convert_to_openmm_force(potential, system)\n        for potential_type, potential in force_field.potentials_by_type.items()\n    }\n    omm_system = create_openmm_system(system, force_field.v_sites)\n\n    if (\n        \"Electrostatics\" in omm_forces\n        and \"vdW\" in omm_forces\n        and len(omm_forces[\"vdW\"]) == 1\n        and isinstance(omm_forces[\"vdW\"][0], openmm.NonbondedForce)\n    ):\n        (electrostatic_force,) = omm_forces.pop(\"Electrostatics\")\n        (vdw_force,) = omm_forces.pop(\"vdW\")\n\n        nonbonded_force = _combine_nonbonded(vdw_force, electrostatic_force)\n        omm_system.addForce(nonbonded_force)\n\n    for forces in omm_forces.values():\n        for force in forces:\n            omm_system.addForce(force)\n\n    _apply_constraints(omm_system, system)\n\n    return omm_system\n</code></pre>"},{"location":"reference/converters/openmm/#smee.converters.openmm.convert_to_openmm_topology","title":"convert_to_openmm_topology","text":"<pre><code>convert_to_openmm_topology(\n    system: TensorSystem,\n) -&gt; Topology\n</code></pre> <p>Convert a SMEE system to an OpenMM topology.</p> Source code in <code>smee/converters/openmm.py</code> <pre><code>def convert_to_openmm_topology(system: smee.TensorSystem) -&gt; openmm.app.Topology:\n    \"\"\"Convert a SMEE system to an OpenMM topology.\"\"\"\n    omm_topology = openmm.app.Topology()\n\n    for topology, n_copies in zip(system.topologies, system.n_copies):\n        chain = omm_topology.addChain()\n\n        is_water = topology.n_atoms == 3 and sorted(\n            int(v) for v in topology.atomic_nums\n        ) == [1, 1, 8]\n\n        residue_name = \"WAT\" if is_water else \"UNK\"\n\n        for _ in range(n_copies):\n            residue = omm_topology.addResidue(residue_name, chain)\n            element_counter = collections.defaultdict(int)\n\n            atoms = {}\n\n            for i, atomic_num in enumerate(topology.atomic_nums):\n                element = openmm.app.Element.getByAtomicNumber(int(atomic_num))\n                element_counter[element.symbol] += 1\n\n                name = element.symbol + (\n                    \"\"\n                    if element_counter[element.symbol] == 1 and element.symbol != \"H\"\n                    else f\"{element_counter[element.symbol]}\"\n                )\n                atoms[i] = omm_topology.addAtom(name, element, residue)\n\n            for i in range(topology.n_v_sites):\n                omm_topology.addAtom(\n                    \"X\", openmm.app.Element.getByAtomicNumber(82), residue\n                )\n\n            for bond_idxs, bond_order in zip(topology.bond_idxs, topology.bond_orders):\n                idx_a, idx_b = int(bond_idxs[0]), int(bond_idxs[1])\n\n                bond_order = int(bond_order)\n                bond_type = {\n                    1: openmm.app.Single,\n                    2: openmm.app.Double,\n                    3: openmm.app.Triple,\n                }[bond_order]\n\n                omm_topology.addBond(atoms[idx_a], atoms[idx_b], bond_type, bond_order)\n\n    return omm_topology\n</code></pre>"},{"location":"reference/converters/openff/","title":"Index","text":""},{"location":"reference/converters/openff/#smee.converters.openff","title":"openff","text":"<p>Tensor representations of SMIRNOFF force fields.</p> <p>Modules:</p> <ul> <li> <code>nonbonded</code>         \u2013          <p>Convert SMIRNOFF non-bonded parameters into tensors.</p> </li> <li> <code>valence</code>         \u2013          <p>Convert SMIRNOFF valence parameters into tensors.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>convert_handlers</code>           \u2013            <p>Convert a set of SMIRNOFF parameter handlers into a set of tensor potentials.</p> </li> <li> <code>convert_interchange</code>           \u2013            <p>Convert a list of interchange objects into tensor potentials.</p> </li> <li> <code>smirnoff_parameter_converter</code>           \u2013            <p>A decorator used to flag a function as being able to convert a parameter handlers</p> </li> </ul>"},{"location":"reference/converters/openff/#smee.converters.openff.convert_handlers","title":"convert_handlers","text":"<pre><code>convert_handlers(\n    handlers: list[SMIRNOFFCollection],\n    topologies: list[Topology],\n    v_site_maps: list[VSiteMap | None] | None = None,\n) -&gt; tuple[TensorPotential, list[ParameterMap]]\n</code></pre> <p>Convert a set of SMIRNOFF parameter handlers into a set of tensor potentials.</p> <p>Parameters:</p> <ul> <li> <code>handlers</code>             (<code>list[SMIRNOFFCollection]</code>)         \u2013          <p>The SMIRNOFF parameter handler collections for a set of interchange objects to convert.</p> </li> <li> <code>topologies</code>             (<code>list[Topology]</code>)         \u2013          <p>The topologies associated with each interchange object.</p> </li> <li> <code>v_site_maps</code>             (<code>list[VSiteMap | None] | None</code>, default:                 <code>None</code> )         \u2013          <p>The v-site maps associated with each interchange object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[TensorPotential, list[ParameterMap]]</code>         \u2013          <p>The potential containing the values of the parameters in each handler collection, and a list of maps (one per topology) between molecule elements (e.g. bond indices) and parameter indices.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from openff.toolkit import ForceField, Molecule\n&gt;&gt;&gt; from openff.interchange import Interchange\n&gt;&gt;&gt;\n&gt;&gt;&gt; force_field = ForceField(\"openff_unconstrained-2.0.0.offxml\")\n&gt;&gt;&gt; molecules = [Molecule.from_smiles(\"CCO\"), Molecule.from_smiles(\"CC\")]\n&gt;&gt;&gt;\n&gt;&gt;&gt; interchanges = [\n...     Interchange.from_smirnoff(force_field, molecule.to_topology())\n...     for molecule in molecules\n... ]\n&gt;&gt;&gt; vdw_handlers = [\n...     interchange.collections[\"vdW\"] for interchange in interchanges\n... ]\n&gt;&gt;&gt;\n&gt;&gt;&gt; vdw_potential, applied_vdw_parameters = convert_handlers(interchanges)\n</code></pre> Source code in <code>smee/converters/openff/_openff.py</code> <pre><code>def convert_handlers(\n    handlers: list[openff.interchange.smirnoff.SMIRNOFFCollection],\n    topologies: list[openff.toolkit.Topology],\n    v_site_maps: list[smee.VSiteMap | None] | None = None,\n) -&gt; tuple[smee.TensorPotential, list[smee.ParameterMap]]:\n    \"\"\"Convert a set of SMIRNOFF parameter handlers into a set of tensor potentials.\n\n    Args:\n        handlers: The SMIRNOFF parameter handler collections for a set of interchange\n            objects to convert.\n        topologies: The topologies associated with each interchange object.\n        v_site_maps: The v-site maps associated with each interchange object.\n\n    Returns:\n        The potential containing the values of the parameters in each handler\n        collection, and a list of maps (one per topology) between molecule elements\n        (e.g. bond indices) and parameter indices.\n\n\n    Examples:\n\n        &gt;&gt;&gt; from openff.toolkit import ForceField, Molecule\n        &gt;&gt;&gt; from openff.interchange import Interchange\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; force_field = ForceField(\"openff_unconstrained-2.0.0.offxml\")\n        &gt;&gt;&gt; molecules = [Molecule.from_smiles(\"CCO\"), Molecule.from_smiles(\"CC\")]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; interchanges = [\n        ...     Interchange.from_smirnoff(force_field, molecule.to_topology())\n        ...     for molecule in molecules\n        ... ]\n        &gt;&gt;&gt; vdw_handlers = [\n        ...     interchange.collections[\"vdW\"] for interchange in interchanges\n        ... ]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; vdw_potential, applied_vdw_parameters = convert_handlers(interchanges)\n    \"\"\"\n    handler_types = {handler.type for handler in handlers}\n    assert len(handler_types) == 1, \"multiple handler types found\"\n    handler_type = next(iter(handler_types))\n\n    assert len(handlers) == len(topologies), \"mismatched number of topologies\"\n\n    importlib.import_module(\"smee.converters.openff.nonbonded\")\n    importlib.import_module(\"smee.converters.openff.valence\")\n\n    if handler_type not in _CONVERTERS:\n        raise NotImplementedError(f\"{handler_type} handlers is not yet supported.\")\n\n    converter = _CONVERTERS[handler_type]\n    converter_spec = inspect.signature(converter)\n\n    converter_kwargs = {}\n\n    if \"topologies\" in converter_spec.parameters:\n        converter_kwargs[\"topologies\"] = topologies\n    if \"v_site_maps\" in converter_spec.parameters:\n        assert v_site_maps is not None, \"v-site maps must be provided\"\n        converter_kwargs[\"v_site_maps\"] = v_site_maps\n\n    return converter(handlers, **converter_kwargs)\n</code></pre>"},{"location":"reference/converters/openff/#smee.converters.openff.convert_interchange","title":"convert_interchange","text":"<pre><code>convert_interchange(\n    interchange: Interchange | list[Interchange],\n) -&gt; tuple[TensorForceField, list[TensorTopology]]\n</code></pre> <p>Convert a list of interchange objects into tensor potentials.</p> <p>Parameters:</p> <ul> <li> <code>interchange</code>             (<code>Interchange | list[Interchange]</code>)         \u2013          <p>The list of (or singile) interchange objects to convert into tensor potentials.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[TensorForceField, list[TensorTopology]]</code>         \u2013          <p>The tensor force field containing the parameters of each handler, and a list (one per interchange) of objects mapping molecule elements (e.g. bonds, angles) to corresponding handler parameters.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from openff.toolkit import ForceField, Molecule\n&gt;&gt;&gt; from openff.interchange import Interchange\n&gt;&gt;&gt;\n&gt;&gt;&gt; force_field = ForceField(\"openff_unconstrained-2.0.0.offxml\")\n&gt;&gt;&gt; molecules = [Molecule.from_smiles(\"CCO\"), Molecule.from_smiles(\"CC\")]\n&gt;&gt;&gt;\n&gt;&gt;&gt; interchanges = [\n...     Interchange.from_smirnoff(force_field, molecule.to_topology())\n...     for molecule in molecules\n... ]\n&gt;&gt;&gt;\n&gt;&gt;&gt; tensor_ff, tensor_topologies = convert_interchange(interchanges)\n</code></pre> Source code in <code>smee/converters/openff/_openff.py</code> <pre><code>def convert_interchange(\n    interchange: openff.interchange.Interchange | list[openff.interchange.Interchange],\n) -&gt; tuple[smee.TensorForceField, list[smee.TensorTopology]]:\n    \"\"\"Convert a list of interchange objects into tensor potentials.\n\n    Args:\n        interchange: The list of (or singile) interchange objects to convert into\n            tensor potentials.\n\n    Returns:\n        The tensor force field containing the parameters of each handler, and a list\n        (one per interchange) of objects mapping molecule elements (e.g. bonds, angles)\n        to corresponding handler parameters.\n\n    Examples:\n\n        &gt;&gt;&gt; from openff.toolkit import ForceField, Molecule\n        &gt;&gt;&gt; from openff.interchange import Interchange\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; force_field = ForceField(\"openff_unconstrained-2.0.0.offxml\")\n        &gt;&gt;&gt; molecules = [Molecule.from_smiles(\"CCO\"), Molecule.from_smiles(\"CC\")]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; interchanges = [\n        ...     Interchange.from_smirnoff(force_field, molecule.to_topology())\n        ...     for molecule in molecules\n        ... ]\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; tensor_ff, tensor_topologies = convert_interchange(interchanges)\n    \"\"\"\n    interchanges = (\n        [interchange]\n        if isinstance(interchange, openff.interchange.Interchange)\n        else interchange\n    )\n    topologies = []\n\n    handler_types = {\n        handler_type\n        for interchange in interchanges\n        for handler_type in interchange.collections\n    }\n    handlers_by_type = {handler_type: [] for handler_type in sorted(handler_types)}\n\n    for interchange in interchanges:\n        for handler_type in handlers_by_type:\n            handler = (\n                None\n                if handler_type not in interchange.collections\n                else interchange.collections[handler_type]\n            )\n            handlers_by_type[handler_type].append(handler)\n\n        topologies.append(interchange.topology)\n\n    v_sites, v_site_maps = None, [None] * len(topologies)\n\n    if \"VirtualSites\" in handlers_by_type:\n        v_sites, v_site_maps = _convert_v_sites(\n            handlers_by_type.pop(\"VirtualSites\"), topologies\n        )\n\n    constraints = [None] * len(topologies)\n\n    if \"Constraints\" in handlers_by_type:\n        constraints = _convert_constraints(handlers_by_type.pop(\"Constraints\"))\n\n    potentials, parameter_maps_by_handler = [], {}\n\n    for handler_type, handlers in handlers_by_type.items():\n        if (\n            sum(len(handler.potentials) for handler in handlers if handler is not None)\n            == 0\n        ):\n            continue\n\n        potential, parameter_map = convert_handlers(handlers, topologies, v_site_maps)\n        potentials.append(potential)\n\n        parameter_maps_by_handler[potential.type] = parameter_map\n\n    tensor_topologies = [\n        _convert_topology(\n            topology,\n            {\n                potential.type: parameter_maps_by_handler[potential.type][i]\n                for potential in potentials\n            },\n            v_site_maps[i],\n            constraints[i],\n        )\n        for i, topology in enumerate(topologies)\n    ]\n\n    tensor_force_field = smee.TensorForceField(potentials, v_sites)\n    return tensor_force_field, tensor_topologies\n</code></pre>"},{"location":"reference/converters/openff/#smee.converters.openff.smirnoff_parameter_converter","title":"smirnoff_parameter_converter","text":"<pre><code>smirnoff_parameter_converter(\n    type_: str, default_units: dict[str, Unit]\n)\n</code></pre> <p>A decorator used to flag a function as being able to convert a parameter handlers parameters into tensors.</p> <p>Parameters:</p> <ul> <li> <code>type_</code>             (<code>str</code>)         \u2013          <p>The type of parameter handler that the decorated function can convert.</p> </li> <li> <code>default_units</code>             (<code>dict[str, Unit]</code>)         \u2013          <p>The default units of each parameter in the handler.</p> </li> </ul> Source code in <code>smee/converters/openff/_openff.py</code> <pre><code>def smirnoff_parameter_converter(\n    type_: str, default_units: dict[str, openff.units.Unit]\n):\n    \"\"\"A decorator used to flag a function as being able to convert a parameter handlers\n    parameters into tensors.\n\n    Args:\n        type_: The type of parameter handler that the decorated function can convert.\n        default_units: The default units of each parameter in the handler.\n    \"\"\"\n\n    def parameter_converter_inner(func):\n        if type_ in _CONVERTERS:\n            raise KeyError(f\"A {type_} converter is already registered.\")\n\n        _CONVERTERS[type_] = func\n        _DEFAULT_UNITS[type_] = default_units\n\n        return func\n\n    return parameter_converter_inner\n</code></pre>"},{"location":"reference/converters/openff/nonbonded/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> nonbonded","text":""},{"location":"reference/converters/openff/nonbonded/#smee.converters.openff.nonbonded","title":"nonbonded","text":"<p>Convert SMIRNOFF non-bonded parameters into tensors.</p> <p>Functions:</p> <ul> <li> <code>convert_nonbonded_handlers</code>           \u2013            <p>Convert a list of SMIRNOFF non-bonded handlers into a tensor potential and</p> </li> </ul>"},{"location":"reference/converters/openff/nonbonded/#smee.converters.openff.nonbonded.convert_nonbonded_handlers","title":"convert_nonbonded_handlers","text":"<pre><code>convert_nonbonded_handlers(\n    handlers: list[SMIRNOFFCollection],\n    handler_type: str,\n    topologies: list[Topology],\n    v_site_maps: list[VSiteMap | None],\n    parameter_cols: tuple[str, ...],\n    attribute_cols: tuple[str, ...] | None = None,\n) -&gt; tuple[TensorPotential, list[NonbondedParameterMap]]\n</code></pre> <p>Convert a list of SMIRNOFF non-bonded handlers into a tensor potential and associated parameter maps.</p> Notes <p>This function assumes that all parameters come from the same force field</p> <p>Parameters:</p> <ul> <li> <code>handlers</code>             (<code>list[SMIRNOFFCollection]</code>)         \u2013          <p>The list of SMIRNOFF non-bonded handlers to convert.</p> </li> <li> <code>handler_type</code>             (<code>str</code>)         \u2013          <p>The type of non-bonded handler being converted.</p> </li> <li> <code>topologies</code>             (<code>list[Topology]</code>)         \u2013          <p>The topologies associated with each handler.</p> </li> <li> <code>v_site_maps</code>             (<code>list[VSiteMap | None]</code>)         \u2013          <p>The virtual site maps associated with each handler.</p> </li> <li> <code>parameter_cols</code>             (<code>tuple[str, ...]</code>)         \u2013          <p>The ordering of the parameter array columns.</p> </li> <li> <code>attribute_cols</code>             (<code>tuple[str, ...] | None</code>, default:                 <code>None</code> )         \u2013          <p>The handler attributes to include in the potential in addition to the intra-molecular scaling factors.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[TensorPotential, list[NonbondedParameterMap]]</code>         \u2013          <p>The potential containing tensors of the parameter values, and a list of parameter maps which map the parameters to the interactions they apply to.</p> </li> </ul> Source code in <code>smee/converters/openff/nonbonded.py</code> <pre><code>def convert_nonbonded_handlers(\n    handlers: list[openff.interchange.smirnoff.SMIRNOFFCollection],\n    handler_type: str,\n    topologies: list[openff.toolkit.Topology],\n    v_site_maps: list[smee.VSiteMap | None],\n    parameter_cols: tuple[str, ...],\n    attribute_cols: tuple[str, ...] | None = None,\n) -&gt; tuple[smee.TensorPotential, list[smee.NonbondedParameterMap]]:\n    \"\"\"Convert a list of SMIRNOFF non-bonded handlers into a tensor potential and\n    associated parameter maps.\n\n    Notes:\n        This function assumes that all parameters come from the same force field\n\n    Args:\n        handlers: The list of SMIRNOFF non-bonded handlers to convert.\n        handler_type: The type of non-bonded handler being converted.\n        topologies: The topologies associated with each handler.\n        v_site_maps: The virtual site maps associated with each handler.\n        parameter_cols: The ordering of the parameter array columns.\n        attribute_cols: The handler attributes to include in the potential *in addition*\n            to the intra-molecular scaling factors.\n\n    Returns:\n        The potential containing tensors of the parameter values, and a list of\n        parameter maps which map the parameters to the interactions they apply to.\n    \"\"\"\n    attribute_cols = attribute_cols if attribute_cols is not None else []\n\n    assert len(topologies) == len(handlers), \"topologies and handlers must match\"\n    assert len(v_site_maps) == len(handlers), \"v-site maps and handlers must match\"\n\n    potential = smee.converters.openff._openff._handlers_to_potential(\n        handlers,\n        handler_type,\n        parameter_cols,\n        (\"scale_12\", \"scale_13\", \"scale_14\", \"scale_15\", *attribute_cols),\n    )\n\n    parameter_key_to_idx = {\n        parameter_key: i for i, parameter_key in enumerate(potential.parameter_keys)\n    }\n    attribute_to_idx = {column: i for i, column in enumerate(potential.attribute_cols)}\n\n    parameter_maps = []\n\n    for handler, topology, v_site_map in zip(handlers, topologies, v_site_maps):\n        assignment_map = collections.defaultdict(lambda: collections.defaultdict(float))\n\n        n_particles = topology.n_atoms + (\n            0 if v_site_map is None else len(v_site_map.keys)\n        )\n\n        for topology_key, parameter_key in handler.key_map.items():\n            if isinstance(topology_key, openff.interchange.models.VirtualSiteKey):\n                continue\n\n            atom_idx = topology_key.atom_indices[0]\n            assignment_map[atom_idx][parameter_key_to_idx[parameter_key]] += 1.0\n\n        for topology_key, parameter_key in handler.key_map.items():\n            if not isinstance(topology_key, openff.interchange.models.VirtualSiteKey):\n                continue\n\n            v_site_idx = v_site_map.key_to_idx[topology_key]\n\n            if parameter_key.associated_handler != \"Electrostatics\":\n                assignment_map[v_site_idx][parameter_key_to_idx[parameter_key]] += 1.0\n            else:\n                for i, atom_idx in enumerate(topology_key.orientation_atom_indices):\n                    mult_key = copy.deepcopy(parameter_key)\n                    mult_key.mult = i\n\n                    assignment_map[atom_idx][parameter_key_to_idx[mult_key]] += 1.0\n                    assignment_map[v_site_idx][parameter_key_to_idx[mult_key]] += -1.0\n\n        assignment_matrix = torch.zeros(\n            (n_particles, len(potential.parameters)), dtype=torch.float64\n        )\n\n        for particle_idx in assignment_map:\n            for parameter_idx, count in assignment_map[particle_idx].items():\n                assignment_matrix[particle_idx, parameter_idx] = count\n\n        exclusion_to_scale = smee.utils.find_exclusions(topology, v_site_map)\n        exclusions = torch.tensor([*exclusion_to_scale])\n        exclusion_scale_idxs = torch.tensor(\n            [[attribute_to_idx[scale]] for scale in exclusion_to_scale.values()],\n            dtype=torch.int64,\n        )\n\n        parameter_map = smee.NonbondedParameterMap(\n            assignment_matrix=assignment_matrix.to_sparse(),\n            exclusions=exclusions,\n            exclusion_scale_idxs=exclusion_scale_idxs,\n        )\n        parameter_maps.append(parameter_map)\n\n    return potential, parameter_maps\n</code></pre>"},{"location":"reference/converters/openff/valence/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> valence","text":""},{"location":"reference/converters/openff/valence/#smee.converters.openff.valence","title":"valence","text":"<p>Convert SMIRNOFF valence parameters into tensors.</p> <p>Functions:</p> <ul> <li> <code>convert_valence_handlers</code>           \u2013            <p>Convert a list of SMIRNOFF valence handlers into a tensor potential and</p> </li> </ul>"},{"location":"reference/converters/openff/valence/#smee.converters.openff.valence.convert_valence_handlers","title":"convert_valence_handlers","text":"<pre><code>convert_valence_handlers(\n    handlers: list[SMIRNOFFCollection],\n    handler_type: str,\n    parameter_cols: tuple[str, ...],\n) -&gt; tuple[TensorPotential, list[ValenceParameterMap]]\n</code></pre> <p>Convert a list of SMIRNOFF valence handlers into a tensor potential and associated parameter maps.</p> Notes <p>This function assumes that all parameters come from the same force field</p> <p>Parameters:</p> <ul> <li> <code>handlers</code>             (<code>list[SMIRNOFFCollection]</code>)         \u2013          <p>The list of SMIRNOFF valence handlers to convert.</p> </li> <li> <code>handler_type</code>             (<code>str</code>)         \u2013          <p>The type of valence handler being converted.</p> </li> <li> <code>parameter_cols</code>             (<code>tuple[str, ...]</code>)         \u2013          <p>The ordering of the parameter array columns.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[TensorPotential, list[ValenceParameterMap]]</code>         \u2013          <p>The potential containing tensors of the parameter values, and a list of parameter maps which map the parameters to the interactions they apply to.</p> </li> </ul> Source code in <code>smee/converters/openff/valence.py</code> <pre><code>def convert_valence_handlers(\n    handlers: list[openff.interchange.smirnoff.SMIRNOFFCollection],\n    handler_type: str,\n    parameter_cols: tuple[str, ...],\n) -&gt; tuple[smee.TensorPotential, list[smee.ValenceParameterMap]]:\n    \"\"\"Convert a list of SMIRNOFF valence handlers into a tensor potential and\n    associated parameter maps.\n\n    Notes:\n        This function assumes that all parameters come from the same force field\n\n    Args:\n        handlers: The list of SMIRNOFF valence handlers to convert.\n        handler_type: The type of valence handler being converted.\n        parameter_cols: The ordering of the parameter array columns.\n\n    Returns:\n        The potential containing tensors of the parameter values, and a list of\n        parameter maps which map the parameters to the interactions they apply to.\n    \"\"\"\n    potential = smee.converters.openff._openff._handlers_to_potential(\n        handlers, handler_type, parameter_cols, None\n    )\n\n    parameter_key_to_idx = {\n        parameter_key: i for i, parameter_key in enumerate(potential.parameter_keys)\n    }\n    parameter_maps = []\n\n    for handler in handlers:\n        particle_idxs = [topology_key.atom_indices for topology_key in handler.key_map]\n\n        assignment_matrix = torch.zeros(\n            (len(particle_idxs), len(potential.parameters)), dtype=torch.float64\n        )\n\n        for i, parameter_key in enumerate(handler.key_map.values()):\n            assignment_matrix[i, parameter_key_to_idx[parameter_key]] += 1.0\n\n        parameter_map = smee.ValenceParameterMap(\n            torch.tensor(particle_idxs), assignment_matrix.to_sparse()\n        )\n        parameter_maps.append(parameter_map)\n\n    return potential, parameter_maps\n</code></pre>"},{"location":"reference/mm/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> mm","text":""},{"location":"reference/mm/#smee.mm","title":"mm","text":"<p>Compute differentiable ensemble averages using OpenMM and SMEE.</p> <p>Classes:</p> <ul> <li> <code>GenerateCoordsConfig</code>         \u2013          <p>Configure how coordinates should be generated for a system using PACKMOL.</p> </li> <li> <code>MinimizationConfig</code>         \u2013          <p>Configure how a system should be energy minimized.</p> </li> <li> <code>SimulationConfig</code>         \u2013          </li> <li> <code>NotEnoughSamplesError</code>         \u2013          <p>An error raised when an ensemble average is attempted with too few samples.</p> </li> <li> <code>TensorReporter</code>         \u2013          <p>A reporter which stores coords, box vectors, reduced potentials and kinetic</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>generate_system_coords</code>           \u2013            <p>Generate coordinates for a system of molecules using PACKMOL.</p> </li> <li> <code>simulate</code>           \u2013            <p>Simulate a SMEE system of molecules or topology.</p> </li> <li> <code>compute_ensemble_averages</code>           \u2013            <p>Compute ensemble average of the potential energy, volume, density,</p> </li> <li> <code>reweight_ensemble_averages</code>           \u2013            <p>Compute the ensemble average of the potential energy, volume, density,</p> </li> <li> <code>tensor_reporter</code>           \u2013            <p>Create a <code>TensorReporter</code> capable of writing frames to a file.</p> </li> <li> <code>unpack_frames</code>           \u2013            <p>Unpack frames saved by a <code>TensorReporter</code>.</p> </li> </ul>"},{"location":"reference/mm/#smee.mm.GenerateCoordsConfig","title":"GenerateCoordsConfig  <code>pydantic-model</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Configure how coordinates should be generated for a system using PACKMOL.</p> <p>Fields:</p> <ul> <li> <code>target_density</code>                 (<code>OpenMMQuantity[_GRAMS_PER_ML]</code>)             </li> <li> <code>scale_factor</code>                 (<code>float</code>)             </li> <li> <code>padding</code>                 (<code>OpenMMQuantity[angstrom]</code>)             </li> <li> <code>tolerance</code>                 (<code>OpenMMQuantity[angstrom]</code>)             </li> <li> <code>seed</code>                 (<code>int | None</code>)             </li> </ul>"},{"location":"reference/mm/#smee.mm.GenerateCoordsConfig.target_density","title":"target_density  <code>pydantic-field</code>","text":"<pre><code>target_density: OpenMMQuantity[_GRAMS_PER_ML] = (\n    0.95 * _GRAMS_PER_ML\n)\n</code></pre> <p>Target mass density for final system with units compatible with g / mL.</p>"},{"location":"reference/mm/#smee.mm.GenerateCoordsConfig.scale_factor","title":"scale_factor  <code>pydantic-field</code>","text":"<pre><code>scale_factor: float = 1.1\n</code></pre> <p>The amount to scale the approximate box size by to help alleviate issues with packing larger molecules.</p>"},{"location":"reference/mm/#smee.mm.GenerateCoordsConfig.padding","title":"padding  <code>pydantic-field</code>","text":"<pre><code>padding: OpenMMQuantity[angstrom] = 2.0 * angstrom\n</code></pre> <p>The amount of padding to add to the final box size to help alleviate PBC issues.</p>"},{"location":"reference/mm/#smee.mm.GenerateCoordsConfig.tolerance","title":"tolerance  <code>pydantic-field</code>","text":"<pre><code>tolerance: OpenMMQuantity[angstrom] = 2.0 * angstrom\n</code></pre> <p>The minimum spacing between molecules during packing.</p>"},{"location":"reference/mm/#smee.mm.GenerateCoordsConfig.seed","title":"seed  <code>pydantic-field</code>","text":"<pre><code>seed: int | None = None\n</code></pre> <p>The random seed to use when generating the coordinates.</p>"},{"location":"reference/mm/#smee.mm.MinimizationConfig","title":"MinimizationConfig  <code>pydantic-model</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Configure how a system should be energy minimized.</p> <p>Fields:</p> <ul> <li> <code>tolerance</code>                 (<code>OpenMMQuantity[_KCAL_PER_MOL / _ANGSTROM]</code>)             </li> <li> <code>max_iterations</code>                 (<code>int</code>)             </li> </ul>"},{"location":"reference/mm/#smee.mm.MinimizationConfig.tolerance","title":"tolerance  <code>pydantic-field</code>","text":"<pre><code>tolerance: OpenMMQuantity[_KCAL_PER_MOL / _ANGSTROM] = (\n    10.0 * _KCAL_PER_MOL / _ANGSTROM\n)\n</code></pre> <p>Minimization will be halted once the root-mean-square value of all force components reaches this tolerance.</p>"},{"location":"reference/mm/#smee.mm.MinimizationConfig.max_iterations","title":"max_iterations  <code>pydantic-field</code>","text":"<pre><code>max_iterations: int = 0\n</code></pre> <p>The maximum number of iterations to perform. If 0, minimization will continue until the tolerance is met.</p>"},{"location":"reference/mm/#smee.mm.SimulationConfig","title":"SimulationConfig  <code>pydantic-model</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Fields:</p> <ul> <li> <code>temperature</code>                 (<code>OpenMMQuantity[kelvin]</code>)             </li> <li> <code>pressure</code>                 (<code>OpenMMQuantity[atmospheres] | None</code>)             </li> <li> <code>n_steps</code>                 (<code>int</code>)             </li> <li> <code>timestep</code>                 (<code>OpenMMQuantity[femtoseconds]</code>)             </li> <li> <code>friction_coeff</code>                 (<code>OpenMMQuantity[1.0 / picoseconds]</code>)             </li> </ul>"},{"location":"reference/mm/#smee.mm.SimulationConfig.temperature","title":"temperature  <code>pydantic-field</code>","text":"<pre><code>temperature: OpenMMQuantity[kelvin]\n</code></pre> <p>The temperature to simulate at.</p>"},{"location":"reference/mm/#smee.mm.SimulationConfig.pressure","title":"pressure  <code>pydantic-field</code>","text":"<pre><code>pressure: OpenMMQuantity[atmospheres] | None\n</code></pre> <p>The pressure to simulate at, or none to run in NVT.</p>"},{"location":"reference/mm/#smee.mm.SimulationConfig.n_steps","title":"n_steps  <code>pydantic-field</code>","text":"<pre><code>n_steps: int\n</code></pre> <p>The number of steps to simulate for.</p>"},{"location":"reference/mm/#smee.mm.SimulationConfig.timestep","title":"timestep  <code>pydantic-field</code>","text":"<pre><code>timestep: OpenMMQuantity[femtoseconds] = 2.0 * femtoseconds\n</code></pre> <p>The timestep to use during the simulation.</p>"},{"location":"reference/mm/#smee.mm.SimulationConfig.friction_coeff","title":"friction_coeff  <code>pydantic-field</code>","text":"<pre><code>friction_coeff: OpenMMQuantity[1.0 / picoseconds] = (\n    1.0 / picoseconds\n)\n</code></pre> <p>The integrator friction coefficient.</p>"},{"location":"reference/mm/#smee.mm.NotEnoughSamplesError","title":"NotEnoughSamplesError","text":"<p>             Bases: <code>ValueError</code></p> <p>An error raised when an ensemble average is attempted with too few samples.</p>"},{"location":"reference/mm/#smee.mm.TensorReporter","title":"TensorReporter","text":"<pre><code>TensorReporter(\n    output_file: BinaryIO,\n    report_interval: int,\n    beta: Quantity,\n    pressure: Quantity | None,\n)\n</code></pre> <p>A reporter which stores coords, box vectors, reduced potentials and kinetic energy using msgpack.</p> <pre><code>report_interval: The interval (in steps) at which to write frames.\nbeta: The inverse temperature the simulation is being run at.\npressure: The pressure the simulation is being run at, or None if NVT /\n    vacuum.\n</code></pre> Source code in <code>smee/mm/_reporters.py</code> <pre><code>def __init__(\n    self,\n    output_file: typing.BinaryIO,\n    report_interval: int,\n    beta: openmm.unit.Quantity,\n    pressure: openmm.unit.Quantity | None,\n):\n    \"\"\"\n\n    Args:\n        output_file: The file to write the frames to.\n        report_interval: The interval (in steps) at which to write frames.\n        beta: The inverse temperature the simulation is being run at.\n        pressure: The pressure the simulation is being run at, or None if NVT /\n            vacuum.\n    \"\"\"\n    self._output_file = output_file\n    self._report_interval = report_interval\n\n    self._beta = beta\n    self._pressure = (\n        None if pressure is None else pressure * openmm.unit.AVOGADRO_CONSTANT_NA\n    )\n</code></pre>"},{"location":"reference/mm/#smee.mm.generate_system_coords","title":"generate_system_coords","text":"<pre><code>generate_system_coords(\n    system: TensorSystem,\n    force_field: TensorForceField | None,\n    config: Optional[GenerateCoordsConfig] = None,\n) -&gt; tuple[Quantity, Quantity]\n</code></pre> <p>Generate coordinates for a system of molecules using PACKMOL.</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to generate coordinates for.</p> </li> <li> <code>force_field</code>             (<code>TensorForceField | None</code>)         \u2013          <p>The force field that describes the geometry of any virtual sites.</p> </li> <li> <code>config</code>             (<code>Optional[GenerateCoordsConfig]</code>, default:                 <code>None</code> )         \u2013          <p>Configuration of how to generate the system coordinates.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Quantity, Quantity]</code>         \u2013          <p>The coordinates with <code>shape=(n_atoms, 3)</code> and box vectors with <code>shape=(3, 3)</code></p> </li> </ul> Source code in <code>smee/mm/_mm.py</code> <pre><code>def generate_system_coords(\n    system: smee.TensorSystem,\n    force_field: smee.TensorForceField | None,\n    config: typing.Optional[\"smee.mm.GenerateCoordsConfig\"] = None,\n) -&gt; tuple[openmm.unit.Quantity, openmm.unit.Quantity]:\n    \"\"\"Generate coordinates for a system of molecules using PACKMOL.\n\n    Args:\n        system: The system to generate coordinates for.\n        force_field: The force field that describes the geometry of any virtual sites.\n        config: Configuration of how to generate the system coordinates.\n\n    Raises:\n        * PACKMOLRuntimeError\n\n    Returns:\n        The coordinates with ``shape=(n_atoms, 3)`` and box vectors with\n        ``shape=(3, 3)``\n    \"\"\"\n\n    system = system.to(\"cpu\")\n    force_field = None if force_field is None else force_field.to(\"cpu\")\n\n    config = config if config is not None else smee.mm.GenerateCoordsConfig()\n\n    box_size = _approximate_box_size(system, config)\n\n    with tempfile.TemporaryDirectory() as tmp_dir:\n        tmp_dir = pathlib.Path(tmp_dir)\n\n        for i, topology in enumerate(system.topologies):\n            xyz = _topology_to_xyz(topology, force_field)\n            (tmp_dir / f\"{i}.xyz\").write_text(xyz)\n\n        input_file = tmp_dir / \"input.txt\"\n        input_file.write_text(\n            _generate_packmol_input(system.n_copies, box_size, config)\n        )\n\n        with input_file.open(\"r\") as file:\n            result = subprocess.run(\n                \"packmol\", stdin=file, capture_output=True, text=True, cwd=tmp_dir\n            )\n\n        if result.returncode != 0 or not result.stdout.find(\"Success!\") &gt; 0:\n            raise PACKMOLRuntimeError(result.stdout)\n\n        output_lines = (tmp_dir / \"output.xyz\").read_text().splitlines()\n\n    coordinates = (\n        numpy.array(\n            [\n                [float(coordinate) for coordinate in coordinate_line.split()[1:]]\n                for coordinate_line in output_lines[2:]\n                if len(coordinate_line) &gt; 0\n            ]\n        )\n        * openmm.unit.angstrom\n    )\n\n    box_vectors = numpy.eye(3) * (box_size + config.padding)\n    return coordinates, box_vectors\n</code></pre>"},{"location":"reference/mm/#smee.mm.simulate","title":"simulate","text":"<pre><code>simulate(\n    system: TensorSystem | TensorTopology,\n    force_field: TensorForceField,\n    coords: Quantity,\n    box_vectors: Quantity | None,\n    equilibrate_configs: list[\n        Union[MinimizationConfig, SimulationConfig]\n    ],\n    production_config: SimulationConfig,\n    production_reporters: list[Any] | None = None,\n    apply_hmr: bool = False,\n) -&gt; State\n</code></pre> <p>Simulate a SMEE system of molecules or topology.</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem | TensorTopology</code>)         \u2013          <p>The system / topology to simulate.</p> </li> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field to simulate with.</p> </li> <li> <code>coords</code>             (<code>Quantity</code>)         \u2013          <p>The coordinates [\u00c5] to use for the simulation. This should be a unit wrapped numpy array with <code>shape=(n_atoms, 3)</code>.</p> </li> <li> <code>box_vectors</code>             (<code>Quantity | None</code>)         \u2013          <p>The box vectors [\u00c5] to use for the simulation if periodic. This should be a unit wrapped numpy array with <code>shape=(3, 3)</code>.</p> </li> <li> <code>equilibrate_configs</code>             (<code>list[Union[MinimizationConfig, SimulationConfig]]</code>)         \u2013          <p>A list of configurations defining the steps to run for equilibration. No data will be stored from these simulations.</p> </li> <li> <code>production_config</code>             (<code>SimulationConfig</code>)         \u2013          <p>The configuration defining the production simulation to run.</p> </li> <li> <code>production_reporters</code>             (<code>list[Any] | None</code>, default:                 <code>None</code> )         \u2013          <p>A list of additional OpenMM reporters to use for the production simulation.</p> </li> <li> <code>apply_hmr</code>             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to apply Hydrogen Mass Repartitioning to the system prior to simulation.</p> </li> </ul> Source code in <code>smee/mm/_mm.py</code> <pre><code>def simulate(\n    system: smee.TensorSystem | smee.TensorTopology,\n    force_field: smee.TensorForceField,\n    coords: openmm.unit.Quantity,\n    box_vectors: openmm.unit.Quantity | None,\n    equilibrate_configs: list[\n        typing.Union[\"smee.mm.MinimizationConfig\", \"smee.mm.SimulationConfig\"]\n    ],\n    production_config: \"smee.mm.SimulationConfig\",\n    production_reporters: list[typing.Any] | None = None,\n    apply_hmr: bool = False,\n) -&gt; openmm.State:\n    \"\"\"Simulate a SMEE system of molecules or topology.\n\n    Args:\n        system: The system / topology to simulate.\n        force_field: The force field to simulate with.\n        coords: The coordinates [\u00c5] to use for the simulation. This should be\n            a unit wrapped numpy array with ``shape=(n_atoms, 3)``.\n        box_vectors: The box vectors [\u00c5] to use for the simulation if periodic. This\n            should be a unit wrapped numpy array with ``shape=(3, 3)``.\n        equilibrate_configs: A list of configurations defining the steps to run for\n            equilibration. No data will be stored from these simulations.\n        production_config: The configuration defining the production simulation to run.\n        production_reporters: A list of additional OpenMM reporters to use for the\n            production simulation.\n        apply_hmr: Whether to apply Hydrogen Mass Repartitioning to the system prior\n            to simulation.\n    \"\"\"\n\n    assert isinstance(coords.value_in_unit(openmm.unit.angstrom), numpy.ndarray)\n    assert isinstance(box_vectors.value_in_unit(openmm.unit.angstrom), numpy.ndarray)\n\n    force_field = force_field.to(\"cpu\")\n\n    system: smee.TensorSystem = (\n        system\n        if isinstance(system, smee.TensorSystem)\n        else smee.TensorSystem([system], [1], False)\n    ).to(\"cpu\")\n\n    requires_pbc = any(\n        config.pressure is not None\n        for config in equilibrate_configs + [production_config]\n        if isinstance(config, smee.mm.SimulationConfig)\n    )\n\n    if not system.is_periodic and requires_pbc:\n        raise ValueError(\"pressure cannot be specified for a non-periodic system\")\n\n    platform = _get_platform(system.is_periodic)\n\n    omm_state = coords, box_vectors\n\n    omm_system = smee.converters.convert_to_openmm_system(force_field, system)\n    omm_topology = smee.converters.convert_to_openmm_topology(system)\n\n    if apply_hmr:\n        _apply_hmr(omm_system, system)\n\n    for i, config in enumerate(equilibrate_configs):\n        _LOGGER.info(f\"running equilibration step {i + 1} / {len(equilibrate_configs)}\")\n\n        if isinstance(config, smee.mm.MinimizationConfig):\n            omm_state = _energy_minimize(omm_system, omm_state, platform, config)\n\n        elif isinstance(config, smee.mm.SimulationConfig):\n            omm_state = _run_simulation(\n                omm_system, omm_topology, omm_state, platform, config, None\n            )\n        else:\n            raise NotImplementedError\n\n        _LOGGER.info(_get_state_log(omm_state))\n\n    _LOGGER.info(\"running production simulation\")\n    omm_state = _run_simulation(\n        omm_system,\n        omm_topology,\n        omm_state,\n        platform,\n        production_config,\n        production_reporters,\n    )\n    _LOGGER.info(_get_state_log(omm_state))\n\n    return omm_state\n</code></pre>"},{"location":"reference/mm/#smee.mm.compute_ensemble_averages","title":"compute_ensemble_averages","text":"<pre><code>compute_ensemble_averages(\n    system: TensorSystem,\n    force_field: TensorForceField,\n    frames_path: Path,\n    temperature: Quantity,\n    pressure: Quantity | None,\n) -&gt; tuple[dict[str, Tensor], dict[str, Tensor]]\n</code></pre> <p>Compute ensemble average of the potential energy, volume, density, and enthalpy (if running NPT) over an MD trajectory.</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to simulate.</p> </li> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field to use.</p> </li> <li> <code>frames_path</code>             (<code>Path</code>)         \u2013          <p>The path to the trajectory to compute the average over.</p> </li> <li> <code>temperature</code>             (<code>Quantity</code>)         \u2013          <p>The temperature that the trajectory was simulated at.</p> </li> <li> <code>pressure</code>             (<code>Quantity | None</code>)         \u2013          <p>The pressure that the trajectory was simulated at.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[dict[str, Tensor], dict[str, Tensor]]</code>         \u2013          <p>A dictionary containing the ensemble averages of the potential energy [kcal/mol], volume [\u00c5^3], density [g/mL], and enthalpy [kcal/mol], and a dictionary containing their standard deviations.</p> </li> </ul> Source code in <code>smee/mm/_ops.py</code> <pre><code>def compute_ensemble_averages(\n    system: smee.TensorSystem,\n    force_field: smee.TensorForceField,\n    frames_path: pathlib.Path,\n    temperature: openmm.unit.Quantity,\n    pressure: openmm.unit.Quantity | None,\n) -&gt; tuple[dict[str, torch.Tensor], dict[str, torch.Tensor]]:\n    \"\"\"Compute ensemble average of the potential energy, volume, density,\n    and enthalpy (if running NPT) over an MD trajectory.\n\n    Args:\n        system: The system to simulate.\n        force_field: The force field to use.\n        frames_path: The path to the trajectory to compute the average over.\n        temperature: The temperature that the trajectory was simulated at.\n        pressure: The pressure that the trajectory was simulated at.\n\n    Returns:\n        A dictionary containing the ensemble averages of the potential energy\n        [kcal/mol], volume [\u00c5^3], density [g/mL], and enthalpy [kcal/mol],\n        and a dictionary containing their standard deviations.\n    \"\"\"\n    tensors, parameter_lookup, attribute_lookup, has_v_sites = _pack_force_field(\n        force_field\n    )\n\n    beta = 1.0 / (openmm.unit.MOLAR_GAS_CONSTANT_R * temperature)\n    beta = beta.value_in_unit(openmm.unit.kilocalorie_per_mole**-1)\n\n    if pressure is not None:\n        pressure = (pressure * openmm.unit.AVOGADRO_CONSTANT_NA).value_in_unit(\n            openmm.unit.kilocalorie_per_mole / openmm.unit.angstrom**3\n        )\n\n    kwargs: _EnsembleAverageKwargs = {\n        \"force_field\": force_field,\n        \"parameter_lookup\": parameter_lookup,\n        \"attribute_lookup\": attribute_lookup,\n        \"has_v_sites\": has_v_sites,\n        \"system\": system,\n        \"frames_path\": frames_path,\n        \"beta\": beta,\n        \"pressure\": pressure,\n    }\n\n    *avg_outputs, columns = _EnsembleAverageOp.apply(kwargs, *tensors)\n\n    avg_values = avg_outputs[: len(avg_outputs) // 2]\n    avg_std = avg_outputs[len(avg_outputs) // 2 :]\n\n    return (\n        {column: avg for avg, column in zip(avg_values, columns)},\n        {column: avg for avg, column in zip(avg_std, columns)},\n    )\n</code></pre>"},{"location":"reference/mm/#smee.mm.reweight_ensemble_averages","title":"reweight_ensemble_averages","text":"<pre><code>reweight_ensemble_averages(\n    system: TensorSystem,\n    force_field: TensorForceField,\n    frames_path: Path,\n    temperature: Quantity,\n    pressure: Quantity | None,\n    min_samples: int = 50,\n) -&gt; dict[str, Tensor]\n</code></pre> <p>Compute the ensemble average of the potential energy, volume, density, and enthalpy (if running NPT) by re-weighting an existing MD trajectory.</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system that was simulated.</p> </li> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The new force field to use.</p> </li> <li> <code>frames_path</code>             (<code>Path</code>)         \u2013          <p>The path to the trajectory to compute the average over.</p> </li> <li> <code>temperature</code>             (<code>Quantity</code>)         \u2013          <p>The temperature that the trajectory was simulated at.</p> </li> <li> <code>pressure</code>             (<code>Quantity | None</code>)         \u2013          <p>The pressure that the trajectory was simulated at.</p> </li> <li> <code>min_samples</code>             (<code>int</code>, default:                 <code>50</code> )         \u2013          <p>The minimum number of samples required to compute the average.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotEnoughSamplesError</code>           \u2013          <p>If the number of effective samples is less than <code>min_samples</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Tensor]</code>         \u2013          <p>A dictionary containing the ensemble averages of the potential energy [kcal/mol], volume [\u00c5^3], density [g/mL], and enthalpy [kcal/mol].</p> </li> </ul> Source code in <code>smee/mm/_ops.py</code> <pre><code>def reweight_ensemble_averages(\n    system: smee.TensorSystem,\n    force_field: smee.TensorForceField,\n    frames_path: pathlib.Path,\n    temperature: openmm.unit.Quantity,\n    pressure: openmm.unit.Quantity | None,\n    min_samples: int = 50,\n) -&gt; dict[str, torch.Tensor]:\n    \"\"\"Compute the ensemble average of the potential energy, volume, density,\n    and enthalpy (if running NPT) by re-weighting an existing MD trajectory.\n\n    Args:\n        system: The system that was simulated.\n        force_field: The new force field to use.\n        frames_path: The path to the trajectory to compute the average over.\n        temperature: The temperature that the trajectory was simulated at.\n        pressure: The pressure that the trajectory was simulated at.\n        min_samples: The minimum number of samples required to compute the average.\n\n    Raises:\n        NotEnoughSamplesError: If the number of effective samples is less than\n            ``min_samples``.\n\n    Returns:\n        A dictionary containing the ensemble averages of the potential energy\n        [kcal/mol], volume [\u00c5^3], density [g/mL], and enthalpy [kcal/mol].\n    \"\"\"\n    tensors, parameter_lookup, attribute_lookup, has_v_sites = _pack_force_field(\n        force_field\n    )\n\n    beta = 1.0 / (openmm.unit.MOLAR_GAS_CONSTANT_R * temperature)\n    beta = beta.value_in_unit(openmm.unit.kilocalorie_per_mole**-1)\n\n    if pressure is not None:\n        pressure = (pressure * openmm.unit.AVOGADRO_CONSTANT_NA).value_in_unit(\n            openmm.unit.kilocalorie_per_mole / openmm.unit.angstrom**3\n        )\n\n    kwargs: _ReweightAverageKwargs = {\n        \"force_field\": force_field,\n        \"parameter_lookup\": parameter_lookup,\n        \"attribute_lookup\": attribute_lookup,\n        \"has_v_sites\": has_v_sites,\n        \"system\": system,\n        \"frames_path\": frames_path,\n        \"beta\": beta,\n        \"pressure\": pressure,\n        \"min_samples\": min_samples,\n    }\n\n    *avg_outputs, columns = _ReweightAverageOp.apply(kwargs, *tensors)\n    return {column: avg for avg, column in zip(avg_outputs, columns)}\n</code></pre>"},{"location":"reference/mm/#smee.mm.tensor_reporter","title":"tensor_reporter","text":"<pre><code>tensor_reporter(\n    output_path: PathLike,\n    report_interval: int,\n    beta: Quantity,\n    pressure: Quantity | None,\n) -&gt; TensorReporter\n</code></pre> <p>Create a <code>TensorReporter</code> capable of writing frames to a file.</p> <p>Parameters:</p> <ul> <li> <code>output_path</code>             (<code>PathLike</code>)         \u2013          <p>The path to write the frames to.</p> </li> <li> <code>report_interval</code>             (<code>int</code>)         \u2013          <p>The interval (in steps) at which to write frames.</p> </li> <li> <code>beta</code>             (<code>Quantity</code>)         \u2013          <p>The inverse temperature the simulation is being run at.</p> </li> <li> <code>pressure</code>             (<code>Quantity | None</code>)         \u2013          <p>The pressure the simulation is being run at, or <code>None</code> if NVT / vacuum.</p> </li> </ul> Source code in <code>smee/mm/_reporters.py</code> <pre><code>@contextlib.contextmanager\ndef tensor_reporter(\n    output_path: os.PathLike,\n    report_interval: int,\n    beta: openmm.unit.Quantity,\n    pressure: openmm.unit.Quantity | None,\n) -&gt; TensorReporter:\n    \"\"\"Create a ``TensorReporter`` capable of writing frames to a file.\n\n    Args:\n        output_path: The path to write the frames to.\n        report_interval: The interval (in steps) at which to write frames.\n        beta: The inverse temperature the simulation is being run at.\n        pressure: The pressure the simulation is being run at, or ``None`` if NVT /\n            vacuum.\n    \"\"\"\n    with open(output_path, \"wb\") as output_file:\n        reporter = TensorReporter(output_file, report_interval, beta, pressure)\n        yield reporter\n</code></pre>"},{"location":"reference/mm/#smee.mm.unpack_frames","title":"unpack_frames","text":"<pre><code>unpack_frames(\n    file: BinaryIO,\n) -&gt; Generator[tuple[Tensor, Tensor, float], None, None]\n</code></pre> <p>Unpack frames saved by a <code>TensorReporter</code>.</p> Source code in <code>smee/mm/_reporters.py</code> <pre><code>def unpack_frames(\n    file: typing.BinaryIO,\n) -&gt; typing.Generator[tuple[torch.Tensor, torch.Tensor, float], None, None]:\n    \"\"\"Unpack frames saved by a ``TensorReporter``.\"\"\"\n\n    unpacker = msgpack.Unpacker(file, object_hook=_decoder)\n\n    for frame in unpacker:\n        yield frame\n</code></pre>"},{"location":"reference/potentials/","title":"Index","text":""},{"location":"reference/potentials/#smee.potentials","title":"potentials","text":"<p>Evaluate the potential energy of parameterized topologies.</p> <p>Modules:</p> <ul> <li> <code>nonbonded</code>         \u2013          <p>Non-bonded potential energy functions.</p> </li> <li> <code>valence</code>         \u2013          <p>Valence potential energy functions.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>broadcast_idxs</code>           \u2013            <p>Broadcasts the particle indices of each topology for a given potential</p> </li> <li> <code>broadcast_parameters</code>           \u2013            <p>Returns parameters for the full system by broadcasting and stacking the</p> </li> <li> <code>compute_energy</code>           \u2013            <p>Computes the potential energy [kcal / mol] of a system / topology in a given</p> </li> <li> <code>compute_energy_potential</code>           \u2013            <p>Computes the potential energy [kcal / mol] due to a SMIRNOFF potential</p> </li> <li> <code>potential_energy_fn</code>           \u2013            <p>A decorator used to flag a function as being able to compute the potential for a</p> </li> </ul>"},{"location":"reference/potentials/#smee.potentials.broadcast_idxs","title":"broadcast_idxs","text":"<pre><code>broadcast_idxs(\n    system: TensorSystem, potential: TensorPotential\n) -&gt; Tensor\n</code></pre> <p>Broadcasts the particle indices of each topology for a given potential to the full system.</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The indices with shape <code>(n_interactions, n_interacting_particles)</code> where <code>n_interacting_particles</code> is 2 for bonds, 3 for angles, etc.</p> </li> </ul> Source code in <code>smee/potentials/_potentials.py</code> <pre><code>def broadcast_idxs(\n    system: smee.TensorSystem, potential: smee.TensorPotential\n) -&gt; torch.Tensor:\n    \"\"\"Broadcasts the particle indices of each topology for a given potential\n    to the full system.\n\n    Args:\n        system: The system.\n        potential: The potential.\n\n    Returns:\n        The indices with shape ``(n_interactions, n_interacting_particles)`` where\n        ``n_interacting_particles`` is 2 for bonds, 3 for angles, etc.\n    \"\"\"\n\n    idx_offset = 0\n\n    per_topology_idxs = []\n\n    for topology, n_copies in zip(system.topologies, system.n_copies):\n        parameter_map = topology.parameters[potential.type]\n        n_interacting_particles = parameter_map.particle_idxs.shape[-1]\n\n        idxs = parameter_map.particle_idxs\n\n        offset = (\n            idx_offset + smee.utils.arange_like(n_copies, idxs) * topology.n_particles\n        )\n\n        if len(idxs) &gt; 0:\n            idxs = offset[:, None, None] + idxs[None, :, :]\n            per_topology_idxs.append(idxs.reshape(-1, n_interacting_particles))\n\n        idx_offset += n_copies * topology.n_particles\n\n    return (\n        torch.zeros((0, 0))\n        if len(per_topology_idxs) == 0\n        else torch.vstack(per_topology_idxs)\n    )\n</code></pre>"},{"location":"reference/potentials/#smee.potentials.broadcast_parameters","title":"broadcast_parameters","text":"<pre><code>broadcast_parameters(\n    system: TensorSystem, potential: TensorPotential\n) -&gt; Tensor\n</code></pre> <p>Returns parameters for the full system by broadcasting and stacking the parameters of each topology.</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential whose parameters should be broadcast.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The parameters for the full system with <code>shape=(n_parameters, n_parameter_cols)</code>.</p> </li> </ul> Source code in <code>smee/potentials/_potentials.py</code> <pre><code>def broadcast_parameters(\n    system: smee.TensorSystem, potential: smee.TensorPotential\n) -&gt; torch.Tensor:\n    \"\"\"Returns parameters for the full system by broadcasting and stacking the\n    parameters of each topology.\n\n    Args:\n        system: The system.\n        potential: The potential whose parameters should be broadcast.\n\n    Returns:\n        The parameters for the full system with\n        ``shape=(n_parameters, n_parameter_cols)``.\n    \"\"\"\n\n    parameters = []\n\n    for topology, n_copies in zip(system.topologies, system.n_copies):\n        parameter_map = topology.parameters[potential.type]\n\n        topology_parameters = parameter_map.assignment_matrix @ potential.parameters\n\n        n_interactions = len(topology_parameters)\n        n_cols = len(potential.parameter_cols)\n\n        topology_parameters = torch.broadcast_to(\n            topology_parameters[None, :, :],\n            (n_copies, n_interactions, n_cols),\n        ).reshape(-1, n_cols)\n\n        parameters.append(topology_parameters)\n\n    return (\n        torch.zeros((0, len(potential.parameter_cols)))\n        if len(parameters) == 0\n        else torch.vstack(parameters)\n    )\n</code></pre>"},{"location":"reference/potentials/#smee.potentials.compute_energy","title":"compute_energy","text":"<pre><code>compute_energy(\n    system: TensorSystem | TensorTopology,\n    force_field: TensorForceField,\n    conformer: Tensor,\n    box_vectors: Tensor | None = None,\n) -&gt; Tensor\n</code></pre> <p>Computes the potential energy [kcal / mol] of a system / topology in a given conformation(s).</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem | TensorTopology</code>)         \u2013          <p>The system or topology to compute the potential energy of.</p> </li> <li> <code>force_field</code>             (<code>TensorForceField</code>)         \u2013          <p>The force field that defines the potential energy function.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer(s) to evaluate the potential at with <code>shape=(n_particles, 3)</code> or <code>shape=(n_confs, n_particles, 3)</code>.</p> </li> <li> <code>box_vectors</code>             (<code>Tensor | None</code>, default:                 <code>None</code> )         \u2013          <p>The box vectors of the system with <code>shape=(3, 3)</code> if the system is periodic, or <code>None</code> if the system is non-periodic.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The potential energy of the conformer(s) [kcal / mol].</p> </li> </ul> Source code in <code>smee/potentials/_potentials.py</code> <pre><code>def compute_energy(\n    system: smee.TensorSystem | smee.TensorTopology,\n    force_field: smee.TensorForceField,\n    conformer: torch.Tensor,\n    box_vectors: torch.Tensor | None = None,\n) -&gt; torch.Tensor:\n    \"\"\"Computes the potential energy [kcal / mol] of a system / topology in a given\n    conformation(s).\n\n    Args:\n        system: The system or topology to compute the potential energy of.\n        force_field: The force field that defines the potential energy function.\n        conformer: The conformer(s) to evaluate the potential at with\n            ``shape=(n_particles, 3)`` or ``shape=(n_confs, n_particles, 3)``.\n        box_vectors: The box vectors of the system with ``shape=(3, 3)`` if the\n            system is periodic, or ``None`` if the system is non-periodic.\n\n    Returns:\n        The potential energy of the conformer(s) [kcal / mol].\n    \"\"\"\n\n    # register the built-in potential energy functions\n    importlib.import_module(\"smee.potentials.nonbonded\")\n    importlib.import_module(\"smee.potentials.valence\")\n\n    system, conformer, box_vectors = _prepare_inputs(system, conformer, box_vectors)\n    pairwise = _precompute_pairwise(system, force_field, conformer, box_vectors)\n\n    energy = smee.utils.zeros_like(\n        conformer.shape[0] if conformer.ndim == 3 else 1, conformer\n    )\n\n    for potential in force_field.potentials:\n        energy += compute_energy_potential(\n            system, potential, conformer, box_vectors, pairwise\n        )\n\n    return energy\n</code></pre>"},{"location":"reference/potentials/#smee.potentials.compute_energy_potential","title":"compute_energy_potential","text":"<pre><code>compute_energy_potential(\n    system: TensorSystem | TensorTopology,\n    potential: TensorPotential,\n    conformer: Tensor,\n    box_vectors: Tensor | None = None,\n    pairwise: Optional[PairwiseDistances] = None,\n) -&gt; Tensor\n</code></pre> <p>Computes the potential energy [kcal / mol] due to a SMIRNOFF potential handler for a given conformer(s).</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem | TensorTopology</code>)         \u2013          <p>The system or topology to compute the potential energy of.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential describing the energy function to compute.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer(s) to evaluate the potential at with <code>shape=(n_particles, 3)</code> or <code>shape=(n_confs, n_particles, 3)</code>.</p> </li> <li> <code>box_vectors</code>             (<code>Tensor | None</code>, default:                 <code>None</code> )         \u2013          <p>The box vectors of the system with <code>shape=(3, 3)</code> or shape=(n_confs, 3, 3)<code>if the system is periodic, or</code>None`` if the system is non-periodic.</p> </li> <li> <code>pairwise</code>             (<code>Optional[PairwiseDistances]</code>, default:                 <code>None</code> )         \u2013          <p>Pre-computed pairwise distances between particles in the system.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The potential energy of the conformer(s) [kcal / mol].</p> </li> </ul> Source code in <code>smee/potentials/_potentials.py</code> <pre><code>def compute_energy_potential(\n    system: smee.TensorSystem | smee.TensorTopology,\n    potential: smee.TensorPotential,\n    conformer: torch.Tensor,\n    box_vectors: torch.Tensor | None = None,\n    pairwise: typing.Optional[\"smee.potentials.nonbonded.PairwiseDistances\"] = None,\n) -&gt; torch.Tensor:\n    \"\"\"Computes the potential energy [kcal / mol] due to a SMIRNOFF potential\n    handler for a given conformer(s).\n\n    Args:\n        system: The system or topology to compute the potential energy of.\n        potential: The potential describing the energy function to compute.\n        conformer: The conformer(s) to evaluate the potential at with\n            ``shape=(n_particles, 3)`` or ``shape=(n_confs, n_particles, 3)``.\n        box_vectors: The box vectors of the system with ``shape=(3, 3)`` or\n            shape=(n_confs, 3, 3)`` if the system is periodic, or ``None`` if the system\n            is non-periodic.\n        pairwise: Pre-computed pairwise distances between particles in the system.\n\n    Returns:\n        The potential energy of the conformer(s) [kcal / mol].\n    \"\"\"\n\n    # register the built-in potential energy functions\n    importlib.import_module(\"smee.potentials.nonbonded\")\n    importlib.import_module(\"smee.potentials.valence\")\n\n    system, conformer, box_vectors = _prepare_inputs(system, conformer, box_vectors)\n\n    energy_fn = _POTENTIAL_ENERGY_FUNCTIONS[(potential.type, potential.fn)]\n    energy_fn_spec = inspect.signature(energy_fn)\n\n    energy_fn_kwargs = {}\n\n    if \"box_vectors\" in energy_fn_spec.parameters:\n        energy_fn_kwargs[\"box_vectors\"] = box_vectors\n    if \"pairwise\" in energy_fn_spec.parameters:\n        energy_fn_kwargs[\"pairwise\"] = pairwise\n\n    return energy_fn(system, potential, conformer, **energy_fn_kwargs)\n</code></pre>"},{"location":"reference/potentials/#smee.potentials.potential_energy_fn","title":"potential_energy_fn","text":"<pre><code>potential_energy_fn(\n    handler_type: str, energy_expression: str\n)\n</code></pre> <p>A decorator used to flag a function as being able to compute the potential for a specific handler and its associated energy expression.</p> Source code in <code>smee/potentials/_potentials.py</code> <pre><code>def potential_energy_fn(handler_type: str, energy_expression: str):\n    \"\"\"A decorator used to flag a function as being able to compute the potential for a\n    specific handler and its associated energy expression.\"\"\"\n\n    def _potential_function_inner(func):\n        if (handler_type, energy_expression) in _POTENTIAL_ENERGY_FUNCTIONS:\n            raise KeyError(\n                f\"A potential energy function is already defined for \"\n                f\"handler={handler_type} fn={energy_expression}.\"\n            )\n\n        _POTENTIAL_ENERGY_FUNCTIONS[(handler_type, energy_expression)] = func\n        return func\n\n    return _potential_function_inner\n</code></pre>"},{"location":"reference/potentials/nonbonded/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> nonbonded","text":""},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded","title":"nonbonded","text":"<p>Non-bonded potential energy functions.</p> <p>Classes:</p> <ul> <li> <code>PairwiseDistances</code>         \u2013          <p>A container for the pairwise distances between all particles, possibly within</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>compute_pairwise_scales</code>           \u2013            <p>Returns the scale factor for each pair of particles in the system by</p> </li> <li> <code>compute_pairwise</code>           \u2013            <p>Computes all pairwise distances between particles in the system.</p> </li> <li> <code>prepare_lrc_types</code>           \u2013            <p>Finds the unique vdW interactions present in a system, ready to use</p> </li> <li> <code>lorentz_berthelot</code>           \u2013            <p>Computes the Lorentz-Berthelot combination rules for the given parameters.</p> </li> <li> <code>compute_lj_energy</code>           \u2013            <p>Computes the potential energy [kcal / mol] of the vdW interactions using the</p> </li> <li> <code>compute_dexp_energy</code>           \u2013            <p>Compute the potential energy [kcal / mol] of the vdW interactions using the</p> </li> <li> <code>compute_coulomb_energy</code>           \u2013            <p>Computes the potential energy [kcal / mol] of the electrostatic interactions</p> </li> </ul>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.PairwiseDistances","title":"PairwiseDistances","text":"<p>             Bases: <code>NamedTuple</code></p> <p>A container for the pairwise distances between all particles, possibly within a given cutoff.</p> <p>Attributes:</p> <ul> <li> <code>idxs</code>             (<code>Tensor</code>)         \u2013          <p>The particle indices of each pair with <code>shape=(n_pairs, 2)</code>.</p> </li> <li> <code>deltas</code>             (<code>Tensor</code>)         \u2013          <p>The vector between each pair with <code>shape=(n_pairs, 3)</code>.</p> </li> <li> <code>distances</code>             (<code>Tensor</code>)         \u2013          <p>The distance between each pair with <code>shape=(n_pairs,)</code>.</p> </li> <li> <code>cutoff</code>             (<code>Tensor | None</code>)         \u2013          <p>The cutoff used when computing the distances.</p> </li> </ul>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.PairwiseDistances.idxs","title":"idxs  <code>instance-attribute</code>","text":"<pre><code>idxs: Tensor\n</code></pre> <p>The particle indices of each pair with <code>shape=(n_pairs, 2)</code>.</p>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.PairwiseDistances.deltas","title":"deltas  <code>instance-attribute</code>","text":"<pre><code>deltas: Tensor\n</code></pre> <p>The vector between each pair with <code>shape=(n_pairs, 3)</code>.</p>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.PairwiseDistances.distances","title":"distances  <code>instance-attribute</code>","text":"<pre><code>distances: Tensor\n</code></pre> <p>The distance between each pair with <code>shape=(n_pairs,)</code>.</p>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.PairwiseDistances.cutoff","title":"cutoff  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cutoff: Tensor | None = None\n</code></pre> <p>The cutoff used when computing the distances.</p>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.compute_pairwise_scales","title":"compute_pairwise_scales","text":"<pre><code>compute_pairwise_scales(\n    system: TensorSystem, potential: TensorPotential\n) -&gt; Tensor\n</code></pre> <p>Returns the scale factor for each pair of particles in the system by broadcasting and stacking the exclusions of each topology.</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential containing the scale factors to broadcast.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The scales for each pair of particles as a flattened upper triangular matrix with <code>shape=(n_particles * (n_particles - 1) / 2,)</code>.</p> </li> </ul> Source code in <code>smee/potentials/nonbonded.py</code> <pre><code>def compute_pairwise_scales(\n    system: smee.TensorSystem, potential: smee.TensorPotential\n) -&gt; torch.Tensor:\n    \"\"\"Returns the scale factor for each pair of particles in the system by\n    broadcasting and stacking the exclusions of each topology.\n\n    Args:\n        system: The system.\n        potential: The potential containing the scale factors to broadcast.\n\n    Returns:\n        The scales for each pair of particles as a flattened upper triangular matrix\n        with ``shape=(n_particles * (n_particles - 1) / 2,)``.\n    \"\"\"\n\n    n_particles = system.n_particles\n    n_pairs = (n_particles * (n_particles - 1)) // 2\n\n    exclusion_idxs, exclusion_scales = _broadcast_exclusions(system, potential)\n\n    pair_scales = smee.utils.ones_like(n_pairs, other=potential.parameters)\n\n    if len(exclusion_idxs) &gt; 0:\n        exclusion_idxs, _ = exclusion_idxs.sort(dim=1)  # ensure upper triangle\n\n        pair_idxs = smee.utils.to_upper_tri_idx(\n            exclusion_idxs[:, 0], exclusion_idxs[:, 1], n_particles\n        )\n        pair_scales[pair_idxs] = exclusion_scales\n\n    return pair_scales\n</code></pre>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.compute_pairwise","title":"compute_pairwise","text":"<pre><code>compute_pairwise(\n    system: TensorSystem,\n    conformer: Tensor,\n    box_vectors: Tensor | None,\n    cutoff: Tensor,\n) -&gt; PairwiseDistances\n</code></pre> <p>Computes all pairwise distances between particles in the system.</p> Notes <p>If the system is not periodic, no cutoff and no PBC will be applied.</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to compute the distances for.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to evaluate the potential at with <code>shape=(n_confs, n_particles, 3)</code> or <code>shape=(n_particles, 3)</code>.</p> </li> <li> <code>box_vectors</code>             (<code>Tensor | None</code>)         \u2013          <p>The box vectors [\u00c5] of the system with <code>shape=(n_confs3, 3)</code> or <code>shape=(3, 3)</code> if the system is periodic, or <code>None</code> otherwise.</p> </li> <li> <code>cutoff</code>             (<code>Tensor</code>)         \u2013          <p>The cutoff [\u00c5] to apply for periodic systems.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PairwiseDistances</code>         \u2013          <p>The pairwise distances between each pair of particles within the cutoff.</p> </li> </ul> Source code in <code>smee/potentials/nonbonded.py</code> <pre><code>def compute_pairwise(\n    system: smee.TensorSystem,\n    conformer: torch.Tensor,\n    box_vectors: torch.Tensor | None,\n    cutoff: torch.Tensor,\n) -&gt; PairwiseDistances:\n    \"\"\"Computes all pairwise distances between particles in the system.\n\n    Notes:\n        If the system is not periodic, no cutoff and no PBC will be applied.\n\n    Args:\n        system: The system to compute the distances for.\n        conformer: The conformer [\u00c5] to evaluate the potential at with\n            ``shape=(n_confs, n_particles, 3)`` or ``shape=(n_particles, 3)``.\n        box_vectors: The box vectors [\u00c5] of the system with ``shape=(n_confs3, 3)``\n            or ``shape=(3, 3)`` if the system is periodic, or ``None`` otherwise.\n        cutoff: The cutoff [\u00c5] to apply for periodic systems.\n\n    Returns:\n        The pairwise distances between each pair of particles within the cutoff.\n    \"\"\"\n    if system.is_periodic:\n        return _compute_pairwise_periodic(conformer, box_vectors, cutoff)\n    else:\n        return _compute_pairwise_non_periodic(conformer)\n</code></pre>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.prepare_lrc_types","title":"prepare_lrc_types","text":"<pre><code>prepare_lrc_types(\n    system: TensorSystem, potential: TensorPotential\n)\n</code></pre> <p>Finds the unique vdW interactions present in a system, ready to use for computing the long range dispersion correction.</p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to prepare the types for.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential to prepare the types for.</p> </li> </ul> <p>Returns:</p> <ul> <li>         \u2013          <p>Two tensors containing the i and j indices into <code>potential.paramaters</code> of each unique interaction parameter excluding <code>i==j</code>, the number of <code>ii</code> interactions with <code>shape=(n_params,)</code>, the numbers of <code>ij</code> interactions with <code>shape=(len(idxs_i),)</code>, and the total number of interactions.</p> </li> </ul> Source code in <code>smee/potentials/nonbonded.py</code> <pre><code>def prepare_lrc_types(system: smee.TensorSystem, potential: smee.TensorPotential):\n    \"\"\"Finds the unique vdW interactions present in a system, ready to use\n    for computing the long range dispersion correction.\n\n    Args:\n        system: The system to prepare the types for.\n        potential: The potential to prepare the types for.\n\n    Returns:\n        Two tensors containing the i and j indices into ``potential.paramaters`` of\n        each unique interaction parameter excluding ``i==j``, the number of ``ii``\n        interactions with ``shape=(n_params,)``, the numbers of ``ij`` interactions\n        with ``shape=(len(idxs_i),)``, and the total number of interactions.\n    \"\"\"\n    n_by_type = collections.defaultdict(int)\n\n    for topology, n_copies in zip(system.topologies, system.n_copies):\n        parameter_counts = topology.parameters[\"vdW\"].assignment_matrix.abs().sum(dim=0)\n\n        for key, count in zip(potential.parameter_keys, parameter_counts):\n            n_by_type[key] += count.item() * n_copies\n\n    counts = smee.utils.tensor_like(\n        [n_by_type[key] for key in potential.parameter_keys], potential.parameters\n    )\n\n    n_ii_interactions = (counts * (counts + 1.0)) / 2.0\n\n    idxs_i, idxs_j = torch.triu_indices(len(counts), len(counts), 1)\n    n_ij_interactions = counts[idxs_i] * counts[idxs_j]\n\n    idxs_ii = torch.arange(len(counts))\n\n    idxs_i = torch.cat([idxs_i, idxs_ii])\n    idxs_j = torch.cat([idxs_j, idxs_ii])\n\n    n_ij_interactions = torch.cat([n_ij_interactions, n_ii_interactions])\n\n    return idxs_i, idxs_j, n_ij_interactions\n</code></pre>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.lorentz_berthelot","title":"lorentz_berthelot","text":"<pre><code>lorentz_berthelot(\n    epsilon_a: Tensor,\n    epsilon_b: Tensor,\n    sigma_a: Tensor,\n    sigma_b: Tensor,\n) -&gt; tuple[Tensor, Tensor]\n</code></pre> <p>Computes the Lorentz-Berthelot combination rules for the given parameters.</p> Notes <p>A 'safe' geometric mean is used to avoid NaNs when the parameters are zero. This will yield non-analytic gradients in some cases.</p> <p>Parameters:</p> <ul> <li> <code>epsilon_a</code>             (<code>Tensor</code>)         \u2013          <p>The epsilon [kcal / mol] values of the first particle in each pair with <code>shape=(n_pairs, 1)</code>.</p> </li> <li> <code>epsilon_b</code>             (<code>Tensor</code>)         \u2013          <p>The epsilon [kcal / mol] values of the second particle in each pair with <code>shape=(n_pairs, 1)</code>.</p> </li> <li> <code>sigma_a</code>             (<code>Tensor</code>)         \u2013          <p>The sigma [kcal / mol] values of the first particle in each pair with <code>shape=(n_pairs, 1)</code>.</p> </li> <li> <code>sigma_b</code>             (<code>Tensor</code>)         \u2013          <p>The sigma [kcal / mol] values of the second particle in each pair with <code>shape=(n_pairs, 1)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Tensor, Tensor]</code>         \u2013          <p>The epsilon [kcal / mol] and sigma [\u00c5] values of each pair, each with <code>shape=(n_pairs, 1)</code>.</p> </li> </ul> Source code in <code>smee/potentials/nonbonded.py</code> <pre><code>def lorentz_berthelot(\n    epsilon_a: torch.Tensor,\n    epsilon_b: torch.Tensor,\n    sigma_a: torch.Tensor,\n    sigma_b: torch.Tensor,\n) -&gt; tuple[torch.Tensor, torch.Tensor]:\n    \"\"\"Computes the Lorentz-Berthelot combination rules for the given parameters.\n\n    Notes:\n        A 'safe' geometric mean is used to avoid NaNs when the parameters are zero.\n        This will yield non-analytic gradients in some cases.\n\n    Args:\n        epsilon_a: The epsilon [kcal / mol] values of the first particle in each pair\n            with ``shape=(n_pairs, 1)``.\n        epsilon_b: The epsilon [kcal / mol] values of the second particle in each pair\n            with ``shape=(n_pairs, 1)``.\n        sigma_a: The sigma [kcal / mol] values of the first particle in each pair\n            with ``shape=(n_pairs, 1)``.\n        sigma_b: The sigma [kcal / mol] values of the second particle in each pair\n            with ``shape=(n_pairs, 1)``.\n\n    Returns:\n        The epsilon [kcal / mol] and sigma [\u00c5] values of each pair, each with\n        ``shape=(n_pairs, 1)``.\n    \"\"\"\n    return smee.utils.geometric_mean(epsilon_a, epsilon_b), 0.5 * (sigma_a + sigma_b)\n</code></pre>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.compute_lj_energy","title":"compute_lj_energy","text":"<pre><code>compute_lj_energy(\n    system: TensorSystem,\n    potential: TensorPotential,\n    conformer: Tensor,\n    box_vectors: Tensor | None = None,\n    pairwise: PairwiseDistances | None = None,\n) -&gt; Tensor\n</code></pre> <p>Computes the potential energy [kcal / mol] of the vdW interactions using the standard Lennard-Jones potential.</p> Notes <ul> <li>No cutoff / switching function will be applied if the system is not   periodic.</li> <li>A switching function will only be applied if the potential has a   <code>switch_width</code> attribute.</li> </ul> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to compute the energy for.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential energy function to evaluate.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to evaluate the potential at with <code>shape=(n_confs, n_particles, 3)</code> or <code>shape=(n_particles, 3)</code>.</p> </li> <li> <code>box_vectors</code>             (<code>Tensor | None</code>, default:                 <code>None</code> )         \u2013          <p>The box vectors [\u00c5] of the system with <code>shape=(n_confs, 3, 3)</code> or <code>shape=(3, 3)</code> if the system is periodic, or <code>None</code> otherwise.</p> </li> <li> <code>pairwise</code>             (<code>PairwiseDistances | None</code>, default:                 <code>None</code> )         \u2013          <p>The pre-computed pairwise distances between each pair of particles in the system. If none, these will be computed within the function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The computed potential energy [kcal / mol] with <code>shape=(n_confs,)</code> if the input conformer has a batch dimension, or <code>shape=()</code> otherwise.</p> </li> </ul> Source code in <code>smee/potentials/nonbonded.py</code> <pre><code>@smee.potentials.potential_energy_fn(\"vdW\", LJ_POTENTIAL)\ndef compute_lj_energy(\n    system: smee.TensorSystem,\n    potential: smee.TensorPotential,\n    conformer: torch.Tensor,\n    box_vectors: torch.Tensor | None = None,\n    pairwise: PairwiseDistances | None = None,\n) -&gt; torch.Tensor:\n    \"\"\"Computes the potential energy [kcal / mol] of the vdW interactions using the\n    standard Lennard-Jones potential.\n\n    Notes:\n        * No cutoff / switching function will be applied if the system is not\n          periodic.\n        * A switching function will only be applied if the potential has a\n          ``switch_width`` attribute.\n\n    Args:\n        system: The system to compute the energy for.\n        potential: The potential energy function to evaluate.\n        conformer: The conformer [\u00c5] to evaluate the potential at with\n            ``shape=(n_confs, n_particles, 3)`` or ``shape=(n_particles, 3)``.\n        box_vectors: The box vectors [\u00c5] of the system with ``shape=(n_confs, 3, 3)``\n            or ``shape=(3, 3)`` if the system is periodic, or ``None`` otherwise.\n        pairwise: The pre-computed pairwise distances between each pair of particles\n            in the system. If none, these will be computed within the function.\n\n    Returns:\n        The computed potential energy [kcal / mol] with ``shape=(n_confs,)`` if the\n        input conformer has a batch dimension, or ``shape=()`` otherwise.\n    \"\"\"\n\n    box_vectors = None if not system.is_periodic else box_vectors\n\n    cutoff = potential.attributes[potential.attribute_cols.index(\"cutoff\")]\n\n    pairwise = (\n        pairwise\n        if pairwise is not None\n        else compute_pairwise(system, conformer, box_vectors, cutoff)\n    )\n\n    if system.is_periodic and not torch.isclose(pairwise.cutoff, cutoff):\n        raise ValueError(\"the pairwise cutoff does not match the potential.\")\n\n    parameters = smee.potentials.broadcast_parameters(system, potential)\n    pair_scales = compute_pairwise_scales(system, potential)\n\n    pairs_1d = smee.utils.to_upper_tri_idx(\n        pairwise.idxs[:, 0], pairwise.idxs[:, 1], len(parameters)\n    )\n    pair_scales = pair_scales[pairs_1d]\n\n    epsilon_column = potential.parameter_cols.index(\"epsilon\")\n    sigma_column = potential.parameter_cols.index(\"sigma\")\n\n    epsilon, sigma = lorentz_berthelot(\n        parameters[pairwise.idxs[:, 0], epsilon_column],\n        parameters[pairwise.idxs[:, 1], epsilon_column],\n        parameters[pairwise.idxs[:, 0], sigma_column],\n        parameters[pairwise.idxs[:, 1], sigma_column],\n    )\n\n    x = (sigma / pairwise.distances) ** 6\n    energies = pair_scales * 4.0 * epsilon * (x * (x - 1.0))\n\n    if not system.is_periodic:\n        return energies.sum(-1)\n\n    switch_fn, switch_width = _compute_switch_fn(potential, pairwise)\n    energies *= switch_fn\n\n    energy = energies.sum(-1)\n    energy += _compute_lj_lrc(\n        system,\n        potential.to(precision=\"double\"),\n        switch_width.double(),\n        pairwise.cutoff.double(),\n        torch.det(box_vectors),\n    )\n\n    return energy\n</code></pre>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.compute_dexp_energy","title":"compute_dexp_energy","text":"<pre><code>compute_dexp_energy(\n    system: TensorSystem,\n    potential: TensorPotential,\n    conformer: Tensor,\n    box_vectors: Tensor | None = None,\n    pairwise: PairwiseDistances | None = None,\n) -&gt; Tensor\n</code></pre> <p>Compute the potential energy [kcal / mol] of the vdW interactions using the double-exponential potential.</p> Notes <ul> <li>No cutoff function will be applied if the system is not periodic.</li> </ul> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to compute the energy for.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential energy function to evaluate.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to evaluate the potential at with <code>shape=(n_confs, n_particles, 3)</code> or <code>shape=(n_particles, 3)</code>.</p> </li> <li> <code>box_vectors</code>             (<code>Tensor | None</code>, default:                 <code>None</code> )         \u2013          <p>The box vectors [\u00c5] of the system with <code>shape=(n_confs, 3, 3)</code> or <code>shape=(3, 3)</code> if the system is periodic, or <code>None</code> otherwise.</p> </li> <li> <code>pairwise</code>             (<code>PairwiseDistances | None</code>, default:                 <code>None</code> )         \u2013          <p>Pre-computed distances between each pair of particles in the system.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The evaluated potential energy [kcal / mol].</p> </li> </ul> Source code in <code>smee/potentials/nonbonded.py</code> <pre><code>@smee.potentials.potential_energy_fn(\"vdW\", DEXP_POTENTIAL)\ndef compute_dexp_energy(\n    system: smee.TensorSystem,\n    potential: smee.TensorPotential,\n    conformer: torch.Tensor,\n    box_vectors: torch.Tensor | None = None,\n    pairwise: PairwiseDistances | None = None,\n) -&gt; torch.Tensor:\n    \"\"\"Compute the potential energy [kcal / mol] of the vdW interactions using the\n    double-exponential potential.\n\n    Notes:\n        * No cutoff function will be applied if the system is not periodic.\n\n    Args:\n        system: The system to compute the energy for.\n        potential: The potential energy function to evaluate.\n        conformer: The conformer [\u00c5] to evaluate the potential at with\n            ``shape=(n_confs, n_particles, 3)`` or ``shape=(n_particles, 3)``.\n        box_vectors: The box vectors [\u00c5] of the system with ``shape=(n_confs, 3, 3)``\n            or ``shape=(3, 3)`` if the system is periodic, or ``None`` otherwise.\n        pairwise: Pre-computed distances between each pair of particles\n            in the system.\n\n    Returns:\n        The evaluated potential energy [kcal / mol].\n    \"\"\"\n    box_vectors = None if not system.is_periodic else box_vectors\n\n    cutoff = potential.attributes[potential.attribute_cols.index(\"cutoff\")]\n\n    pairwise = (\n        pairwise\n        if pairwise is not None\n        else compute_pairwise(system, conformer, box_vectors, cutoff)\n    )\n\n    if system.is_periodic and not torch.isclose(pairwise.cutoff, cutoff):\n        raise ValueError(\"the pairwise cutoff does not match the potential.\")\n\n    parameters = smee.potentials.broadcast_parameters(system, potential)\n    pair_scales = compute_pairwise_scales(system, potential)\n\n    pairs_1d = smee.utils.to_upper_tri_idx(\n        pairwise.idxs[:, 0], pairwise.idxs[:, 1], len(parameters)\n    )\n    pair_scales = pair_scales[pairs_1d]\n\n    epsilon_column = potential.parameter_cols.index(\"epsilon\")\n    r_min_column = potential.parameter_cols.index(\"r_min\")\n\n    epsilon, r_min = smee.potentials.nonbonded.lorentz_berthelot(\n        parameters[pairwise.idxs[:, 0], epsilon_column],\n        parameters[pairwise.idxs[:, 1], epsilon_column],\n        parameters[pairwise.idxs[:, 0], r_min_column],\n        parameters[pairwise.idxs[:, 1], r_min_column],\n    )\n\n    alpha = potential.attributes[potential.attribute_cols.index(\"alpha\")]\n    beta = potential.attributes[potential.attribute_cols.index(\"beta\")]\n\n    x = pairwise.distances / r_min\n\n    energies_repulsion = beta / (alpha - beta) * torch.exp(alpha * (1.0 - x))\n    energies_attraction = alpha / (alpha - beta) * torch.exp(beta * (1.0 - x))\n\n    energies = pair_scales * epsilon * (energies_repulsion - energies_attraction)\n\n    if not system.is_periodic:\n        return energies.sum(-1)\n\n    switch_fn, switch_width = _compute_switch_fn(potential, pairwise)\n    energies *= switch_fn\n\n    energy = energies.sum(-1)\n\n    energy += _compute_dexp_lrc(\n        system,\n        potential.to(precision=\"double\"),\n        switch_width.double(),\n        pairwise.cutoff.double(),\n        torch.det(box_vectors),\n    )\n\n    return energy\n</code></pre>"},{"location":"reference/potentials/nonbonded/#smee.potentials.nonbonded.compute_coulomb_energy","title":"compute_coulomb_energy","text":"<pre><code>compute_coulomb_energy(\n    system: TensorSystem,\n    potential: TensorPotential,\n    conformer: Tensor,\n    box_vectors: Tensor | None = None,\n    pairwise: PairwiseDistances | None = None,\n) -&gt; Tensor\n</code></pre> <p>Computes the potential energy [kcal / mol] of the electrostatic interactions using the Coulomb potential.</p> Notes <ul> <li>No cutoff will be applied if the system is not periodic.</li> <li>PME will be used to compute the energy if the system is periodic.</li> </ul> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to compute the energy for.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential energy function to evaluate.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to evaluate the potential at with <code>shape=(n_confs, n_particles, 3)</code> or <code>shape=(n_particles, 3)</code>.</p> </li> <li> <code>box_vectors</code>             (<code>Tensor | None</code>, default:                 <code>None</code> )         \u2013          <p>The box vectors [\u00c5] of the system with <code>shape=(n_confs, 3, 3)</code> or <code>shape=(3, 3)</code> if the system is periodic, or <code>None</code> otherwise.</p> </li> <li> <code>pairwise</code>             (<code>PairwiseDistances | None</code>, default:                 <code>None</code> )         \u2013          <p>The pre-computed pairwise distances between each pair of particles in the system. If none, these will be computed within the function.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The computed potential energy [kcal / mol] with <code>shape=(n_confs,)</code> if the input conformer has a batch dimension, or <code>shape=()</code> otherwise.</p> </li> </ul> Source code in <code>smee/potentials/nonbonded.py</code> <pre><code>@smee.potentials.potential_energy_fn(\"Electrostatics\", _COULOMB_POTENTIAL)\ndef compute_coulomb_energy(\n    system: smee.TensorSystem,\n    potential: smee.TensorPotential,\n    conformer: torch.Tensor,\n    box_vectors: torch.Tensor | None = None,\n    pairwise: PairwiseDistances | None = None,\n) -&gt; torch.Tensor:\n    \"\"\"Computes the potential energy [kcal / mol] of the electrostatic interactions\n    using the Coulomb potential.\n\n    Notes:\n        * No cutoff will be applied if the system is not periodic.\n        * PME will be used to compute the energy if the system is periodic.\n\n    Args:\n        system: The system to compute the energy for.\n        potential: The potential energy function to evaluate.\n        conformer: The conformer [\u00c5] to evaluate the potential at with\n            ``shape=(n_confs, n_particles, 3)`` or ``shape=(n_particles, 3)``.\n        box_vectors: The box vectors [\u00c5] of the system with ``shape=(n_confs, 3, 3)``\n            or ``shape=(3, 3)`` if the system is periodic, or ``None`` otherwise.\n        pairwise: The pre-computed pairwise distances between each pair of particles\n            in the system. If none, these will be computed within the function.\n\n    Returns:\n        The computed potential energy [kcal / mol] with ``shape=(n_confs,)`` if the\n        input conformer has a batch dimension, or ``shape=()`` otherwise.\n    \"\"\"\n\n    box_vectors = None if not system.is_periodic else box_vectors\n\n    cutoff = potential.attributes[potential.attribute_cols.index(\"cutoff\")]\n\n    pairwise = (\n        pairwise\n        if pairwise is not None\n        else compute_pairwise(system, conformer, box_vectors, cutoff)\n    )\n\n    if system.is_periodic and not torch.isclose(pairwise.cutoff, cutoff):\n        raise ValueError(\"the distance cutoff does not match the potential.\")\n\n    if system.is_periodic:\n        return _compute_coulomb_energy_periodic(\n            system, conformer, box_vectors, potential, pairwise\n        )\n    else:\n        return _compute_coulomb_energy_non_periodic(system, potential, pairwise)\n</code></pre>"},{"location":"reference/potentials/valence/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> valence","text":""},{"location":"reference/potentials/valence/#smee.potentials.valence","title":"valence","text":"<p>Valence potential energy functions.</p> <p>Functions:</p> <ul> <li> <code>compute_harmonic_bond_energy</code>           \u2013            <p>Compute the potential energy [kcal / mol] of a set of bonds for a given</p> </li> <li> <code>compute_harmonic_angle_energy</code>           \u2013            <p>Compute the potential energy [kcal / mol] of a set of valence angles for a given</p> </li> <li> <code>compute_cosine_proper_torsion_energy</code>           \u2013            <p>Compute the potential energy [kcal / mol] of a set of proper torsions</p> </li> <li> <code>compute_cosine_improper_torsion_energy</code>           \u2013            <p>Compute the potential energy [kcal / mol] of a set of improper torsions</p> </li> </ul>"},{"location":"reference/potentials/valence/#smee.potentials.valence.compute_harmonic_bond_energy","title":"compute_harmonic_bond_energy","text":"<pre><code>compute_harmonic_bond_energy(\n    system: TensorSystem,\n    potential: TensorPotential,\n    conformer: Tensor,\n) -&gt; Tensor\n</code></pre> <p>Compute the potential energy [kcal / mol] of a set of bonds for a given conformer using a harmonic potential of the form <code>1/2 * k * (r - length) ** 2</code></p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to compute the energy for.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential energy function to evaluate.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to evaluate the potential at with <code>shape=(n_confs, n_particles, 3)</code> or <code>shape=(n_particles, 3)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The computed potential energy [kcal / mol].</p> </li> </ul> Source code in <code>smee/potentials/valence.py</code> <pre><code>@smee.potentials.potential_energy_fn(\"Bonds\", \"k/2*(r-length)**2\")\ndef compute_harmonic_bond_energy(\n    system: smee.TensorSystem,\n    potential: smee.TensorPotential,\n    conformer: torch.Tensor,\n) -&gt; torch.Tensor:\n    \"\"\"Compute the potential energy [kcal / mol] of a set of bonds for a given\n    conformer using a harmonic potential of the form ``1/2 * k * (r - length) ** 2``\n\n    Args:\n        system: The system to compute the energy for.\n        potential: The potential energy function to evaluate.\n        conformer: The conformer [\u00c5] to evaluate the potential at with\n            ``shape=(n_confs, n_particles, 3)`` or ``shape=(n_particles, 3)``.\n\n    Returns:\n        The computed potential energy [kcal / mol].\n    \"\"\"\n\n    parameters = smee.potentials.broadcast_parameters(system, potential)\n    particle_idxs = smee.potentials.broadcast_idxs(system, potential)\n\n    _, distances = smee.geometry.compute_bond_vectors(conformer, particle_idxs)\n\n    k = parameters[:, potential.parameter_cols.index(\"k\")]\n    length = parameters[:, potential.parameter_cols.index(\"length\")]\n\n    return (0.5 * k * (distances - length) ** 2).sum(-1)\n</code></pre>"},{"location":"reference/potentials/valence/#smee.potentials.valence.compute_harmonic_angle_energy","title":"compute_harmonic_angle_energy","text":"<pre><code>compute_harmonic_angle_energy(\n    system: TensorSystem,\n    potential: TensorPotential,\n    conformer: Tensor,\n) -&gt; Tensor\n</code></pre> <p>Compute the potential energy [kcal / mol] of a set of valence angles for a given conformer using a harmonic potential of the form <code>1/2 * k * (theta - angle) ** 2</code></p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to compute the energy for.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential energy function to evaluate.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to evaluate the potential at with <code>shape=(n_confs, n_particles, 3)</code> or <code>shape=(n_particles, 3)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The computed potential energy [kcal / mol].</p> </li> </ul> Source code in <code>smee/potentials/valence.py</code> <pre><code>@smee.potentials.potential_energy_fn(\"Angles\", \"k/2*(theta-angle)**2\")\ndef compute_harmonic_angle_energy(\n    system: smee.TensorSystem,\n    potential: smee.TensorPotential,\n    conformer: torch.Tensor,\n) -&gt; torch.Tensor:\n    \"\"\"Compute the potential energy [kcal / mol] of a set of valence angles for a given\n    conformer using a harmonic potential of the form ``1/2 * k * (theta - angle) ** 2``\n\n    Args:\n        system: The system to compute the energy for.\n        potential: The potential energy function to evaluate.\n        conformer: The conformer [\u00c5] to evaluate the potential at with\n            ``shape=(n_confs, n_particles, 3)`` or ``shape=(n_particles, 3)``.\n\n    Returns:\n        The computed potential energy [kcal / mol].\n    \"\"\"\n\n    parameters = smee.potentials.broadcast_parameters(system, potential)\n    particle_idxs = smee.potentials.broadcast_idxs(system, potential)\n\n    theta = smee.geometry.compute_angles(conformer, particle_idxs)\n\n    k = parameters[:, potential.parameter_cols.index(\"k\")]\n    angle = parameters[:, potential.parameter_cols.index(\"angle\")]\n\n    return (0.5 * k * (theta - angle) ** 2).sum(-1)\n</code></pre>"},{"location":"reference/potentials/valence/#smee.potentials.valence.compute_cosine_proper_torsion_energy","title":"compute_cosine_proper_torsion_energy","text":"<pre><code>compute_cosine_proper_torsion_energy(\n    system: TensorSystem,\n    potential: TensorPotential,\n    conformer: Tensor,\n) -&gt; Tensor\n</code></pre> <p>Compute the potential energy [kcal / mol] of a set of proper torsions for a given conformer using a cosine potential of the form:</p> <p><code>k*(1+cos(periodicity*theta-phase))</code></p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to compute the energy for.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential energy function to evaluate.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to evaluate the potential at with <code>shape=(n_confs, n_particles, 3)</code> or <code>shape=(n_particles, 3)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The computed potential energy [kcal / mol].</p> </li> </ul> Source code in <code>smee/potentials/valence.py</code> <pre><code>@smee.potentials.potential_energy_fn(\n    \"ProperTorsions\", \"k*(1+cos(periodicity*theta-phase))\"\n)\ndef compute_cosine_proper_torsion_energy(\n    system: smee.TensorSystem,\n    potential: smee.TensorPotential,\n    conformer: torch.Tensor,\n) -&gt; torch.Tensor:\n    \"\"\"Compute the potential energy [kcal / mol] of a set of proper torsions\n    for a given conformer using a cosine potential of the form:\n\n    `k*(1+cos(periodicity*theta-phase))`\n\n    Args:\n        system: The system to compute the energy for.\n        potential: The potential energy function to evaluate.\n        conformer: The conformer [\u00c5] to evaluate the potential at with\n            ``shape=(n_confs, n_particles, 3)`` or ``shape=(n_particles, 3)``.\n\n    Returns:\n        The computed potential energy [kcal / mol].\n    \"\"\"\n    return _compute_cosine_torsion_energy(system, potential, conformer)\n</code></pre>"},{"location":"reference/potentials/valence/#smee.potentials.valence.compute_cosine_improper_torsion_energy","title":"compute_cosine_improper_torsion_energy","text":"<pre><code>compute_cosine_improper_torsion_energy(\n    system: TensorSystem,\n    potential: TensorPotential,\n    conformer: Tensor,\n) -&gt; Tensor\n</code></pre> <p>Compute the potential energy [kcal / mol] of a set of improper torsions for a given conformer using a cosine potential of the form:</p> <p><code>k*(1+cos(periodicity*theta-phase))</code></p> <p>Parameters:</p> <ul> <li> <code>system</code>             (<code>TensorSystem</code>)         \u2013          <p>The system to compute the energy for.</p> </li> <li> <code>potential</code>             (<code>TensorPotential</code>)         \u2013          <p>The potential energy function to evaluate.</p> </li> <li> <code>conformer</code>             (<code>Tensor</code>)         \u2013          <p>The conformer [\u00c5] to evaluate the potential at with <code>shape=(n_confs, n_particles, 3)</code> or <code>shape=(n_particles, 3)</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tensor</code>         \u2013          <p>The computed potential energy [kcal / mol].</p> </li> </ul> Source code in <code>smee/potentials/valence.py</code> <pre><code>@smee.potentials.potential_energy_fn(\n    \"ImproperTorsions\", \"k*(1+cos(periodicity*theta-phase))\"\n)\ndef compute_cosine_improper_torsion_energy(\n    system: smee.TensorSystem,\n    potential: smee.TensorPotential,\n    conformer: torch.Tensor,\n) -&gt; torch.Tensor:\n    \"\"\"Compute the potential energy [kcal / mol] of a set of improper torsions\n    for a given conformer using a cosine potential of the form:\n\n    `k*(1+cos(periodicity*theta-phase))`\n\n    Args:\n        system: The system to compute the energy for.\n        potential: The potential energy function to evaluate.\n        conformer: The conformer [\u00c5] to evaluate the potential at with\n            ``shape=(n_confs, n_particles, 3)`` or ``shape=(n_particles, 3)``.\n\n    Returns:\n        The computed potential energy [kcal / mol].\n    \"\"\"\n    return _compute_cosine_torsion_energy(system, potential, conformer)\n</code></pre>"}]}